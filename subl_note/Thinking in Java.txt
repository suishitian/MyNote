第一章 对象概论

1.Java是基于C++的
2.is-a:继承的子类具有和基类完全相同的接口(不添加新方法)，这种称之为纯粹替代。eg：一个园是一个几何形状
  is-like-a：继承的子类具有超过基类的方法，扩展，不是纯粹替代。eg:飞机和车都是交通工具，飞机多了起飞和降落的方法。
  has-a：组合方式，在对象的定义内内嵌了另一种对象，并且在对象内部隐式的使用其功能(而不是开发他的特殊版本)，这是使用组合方式，而不是继承，这种关系叫做has-a。
3.java所有方法都是默认为后期绑定：当向对象发送消息时，被调用的代码直到运行时才能确定。为了执行后期绑定，java使用一小段代码用来替代绝对地址调用，这段代码用来计算方法体的地址。
4.java是单根继承结构：所有类都继承自一个类(在java中是Object类，C++是几乎唯一不是单根继承的语言)
  单根继承的好处：
  (1)非单根继承获得新类库的时候容易用到一些不兼容的接口。
  (2)单根继承保证所有对象都有某些同样的功能，所以对象很容易在堆上创建。
  (3)java的单根继承使垃圾回收变得容易的多。
5.容器：在解决某个问题时不知道需要多少对象，并且不知道对象将存活多久时，为了解决这个问题，引入另一种对象人，让这种对象持有其他对象的引用。这种对象就是容器。
6.泛型：用来解决Object容器取出对象之后的向下转型的不安全问题(Object可能会向下转型为非继承关系的导出类)
       eg:	ArrayList<shape> list = new ArrayList<>();  ----  其中shape就是限定的泛型(也称为参数化类型)
7.java创建对象在堆上，使用完全动态内存分配方式。

第二章，一切都是对象

2.1 用引用操作对象：
  1.java中几乎一切都是对象，用过对对象持有引用来操作对象。但是并不是每一个引用都需要有对相应的对象，可以持有一个空的引用。
    eg: String s;  ----  这句不会报错，因为创建的只是引用。如果对s进行操作，就会返回错误。
2.2 创建对象
  2.2.1 存储位置
    (1)寄存器：在处理器内部，无法在程序中直接控制。
    (2)stack：位于RAM。先进先出，性能高但是限制程序的灵活性。
    (3)heap：位于RAM，用来存放所有java对象，在堆中进行对象的储存和清理会比stack的性能差一些。
    (4)常量存储：有些永远不会被改变的常量值可以处在的程序的内部。
    (5)非RAM储存：持久化储存，程序不在运行时，数据依然存在(JDBC,Hibernate)
  2.2.2 特例
    1.基本类型在创建时由于太小，不需要放在堆中，所以生成一个并非是引用的自动变量，这个变量储存值并且放在stack中。
    2.基本类型即使没有被初始化也会被自动赋予一个默认值(只在基本类型作为类的成员时生效)。
    基本类型所占大小(大小不随机型的改变而改变)：
    基本类型 	大小 	最小值 		最大值 				包装器类型 			无初值创建时候的默认值(作为类的成员)
    boolean 	16-bit 	Unicode 0 	Unicode 2^16-1		Boolean 			false
    char		16		-128		+127				Character 			null('\u0000')
    byte		8		-128		+127				Byte 				(byte)0
    short		16		-2^15		+(2^15)-1			Short 				(short)0
    int			32		-2^31		+(2^31)-1			Integer 			0
    long		64		-2^63		+(2^63)-1			Long 				0L
    float		32		IEEE754		IEEE754				Float 				0.0f
    double		64		IEEE754		IEEE754				Double 				0.0d
    void		-		-			-					Void 				-
    包装器类可以在堆中创建一个对象用来表示一个基本类型
    eg:	char c = 'x';
    	Charater c = new Charater(c);
    	Charater ch = new Charater('x');
    	Charater ch1 = 'x';  ----  自动将基本类型包装为包装类
    	char c = ch;  ----  可以反向转换
2.3 不需要手动销毁对象
  2.3.1 作用域
    1.作用域内的变量值用于作用于结束之前。
    2.eg:
    {
      int x = 5;
      {
        int x = 8; ---- 在C++中合法，小的作用于会隐藏大的作用域
      }
    }
    在java中不合法。
  2.3.2 对象的作用域
    1.对象可以存活在作用于之外
    eg:
    {
      String s = new String('x');
    }  ----  作用域结束之后引用消失，但是对象还在(堆中)，但是无法在访问这个对象(针对本段代码)。
    2.不在被引用的对象将会由垃圾回收器自动回收。
2.4 类
  用class关键字创建类
  2.4.1 字段和方法
    1.字段：类内部的数据成员
    2.方法：成员函数
  1.在类成员中创建基本类型会被赋予默认值，但是不适用于局部变量，局部变量中基本类型会得到任意值。
2.5 方法，参数，返回值
  1.方法签名：由函数名和参数列表唯一的标识出某个方法。
  2.5.1 参数列表
    1.参数列表传递的是对象的引用(除了基本类型外，java几乎任何地方的传值都是对象的引用)
2.6 java程序构建
  2.6.3 static关键字
    1.static可以满足两方面的需要：
      (1)只想为特定域分配一定的存储空间，而不去考虑需要创建多少对象
      (2)希望某个方法不予包含他的类的任何对象关联在一起，即不创建这个类也能调用此方法。
    2.因为static方法不依赖其包含类的对象的存在，所以static方法中不能通过调用其它非static域(数据成员)或者非static方法而没有指定其命名对象，来直接访问非static域或者非static方法。
    3.static域是一处不同于stack和heap的区域，所以即使创建了两个对象，对象中的static数据成成员和方法也只有一个(存放在static域中)。通过这种方法可以将static用作同种类之间的共享全局变量使用。
    4.对static数据成员或方法的调用最好使用ClassName.method()，ClassName.dataName的方式，在某些情况下会为编译器进行优化提供了更好的机会。
2.7 java程序
  1.java.lang会被自动导入到每一个Java文件中。
  2.public static void main(String[] args){//...}  ----  其中的args参数用于存储命令行参数。
  2.7.1 编译和运行
    1.JDK:Java Developer`s Kit,java开发人员工具包
    2.编译方式：
      javac HelloWorld.java
      java HelloDate
2.9 编译风格
  1.驼峰式：类名所有单词的首字母大写，其他情况第一个单词的首字母小写剩下首字母大写。不要用下划线连接单词。

第三章 操作符

3.4 =号赋值
  1.对常量进行赋值：(1)左边必须是一个可以容纳常量的储存空间(一个变量名)，右边可以是一切可以产生一个常量的表达式。
  				  (2)对常量之间进行=操作，将右侧的值复制给左侧，复制之后改变任何一方，另一方不受影响。
  2.对对象的=操作：
    eg：Tank t1 = new Tank();
        Tank t2 = new Tank();
        t1 = t2;  ----  将t2的引用付给t1，原t1的引用(指向对象t1的引用)被覆盖为t2的引用(指向对象t2)。最终t1,t2都指向相同的对象，原t1的对象因为没有引用会被垃圾回收器回收(别名现象)。
  3.方法参数列表中的别名现象：方法的参数列表传递的同样是对象的引用，所以在方法内在对输入的对象进行修改的时候，方法外的对象也会获得同样的修改(因为都指向用一个对象，相反基本类型则不受影响)。
3.5 算数操作符
  3.5.1
    1.一元操作符(让常量变号的-或者+)中的+号只是为了与-相对应，但是还有将较小类型的操作数提升为int的功能。
3.6 自增自减
  1.前缀自增自减表示自增自减操作在此表达式之前，相反后缀表示自增自减操作在此表达式之后。
3.7 关系操作符
  1.！=，==只适用于基本类型，对象需要使用其他方法。对象间的==，！=操作是引用间的比较。
  eg：Integer t1 = new Integer(55);
      Integer t2 = new Integer(55);
      System.out.println(t1==t2);  ----  false因为两个引用指向不同的对象，所以引用不相同，t1!=t2
      System.out.println(t1!=t2);  ----  true
  2.对象间的是否相同的比较要用t1.equals(t2)，此方法需要在对象定义中覆盖过equals()方法(包装类Inetger已经实现好了equals()方法)。
  3.对于自己新定义的方法：
  eg：class Value{//...}
      Value v1 = new Value(11);
      Value v2 = new Value(12);
      System.out.println(v1.equals(v2));  ----  false因为Value没有实现equals()方法，equals()会默认的进行引用的比较所以为false。
3.8 关系操作符
  1.&&，||，！：与或非
  2.短路：一旦能够明确无误地确定整个表达式的值，则不再继续计算表达式的余下部分。所以表达式后面的部分可能不会被运算。
  eg：test1() && test2() && test3();  ----  如果test1()表达式为true则继续，如果test1()为false则停止计算返回false
  3.短路特性能够带来潜在的性能的提升，也可以用于进行有序的连续逻辑操作。
  eg：int[] list = getAnArray();
      if(list!=null && list.length==0) {//...}  ----  list.length==0必须在右侧，因为如果list为null的话，list没有length属性，所以需要第一个表达式不成立的时候对后一个进行短路以避免不必要的错误出现。
3.9 直接常量
  1.有时编译器不能准确知道要生成的类型，必须对编译器加以引导，就需要在与直接常量添加一些字符来获取额外信息。
  添加的字符 	代表类型 	eg
  L(l容易混淆) 	long 		200L
  F 			float 		1f
  D 			double 		5d
  0x## 			16进制数 	0x2f
  0## 			8进制数 		0117
  2.二进制数没有直接常量表示法，但是可以使用16进制和8进制以2进制显示结果，使用Integer和Long的静态方法toBinaryString()。
  3.9.1 指数计数法
    1.e:10 to the power
    eg：1.39e-43f  ----  1.39*10^-43类型为float
    	47e47d  ----  4.7*10^48(也是4.7e48d)类型为double
    	其中e大写小写都表示10的幂
3.10 位操作符
  1.&,|,~,^：与,或,非,异或(位操作,输入输出都与0,1有关)。
  2.&=,|=,^=都合法(效果与+=类似)，~=不合法，因为~是一元操作符。
  3!.布尔值可以使用位操作符，效果与逻辑操作符相同(~不能用于布尔值避免与逻辑not混淆)。
  4!.布尔值在使用逻辑操作时，使用位操作符比使用逻辑操作符多了一个异或操作。
  5!.布尔值在使用位操作符时，没有短路效果！！！
  6.布尔值不能使用在移位表达式中。
3.11 移位操作符
  1.操作对象为整数类型。
  2.有符号的移位操作(>>,<<)：(1)右移位：按照操作符右侧制定的位数将操作符左边的操作数想右移动。若符号为正则高位插0，若符号为负，则在高位差1。
                           (2)左移位：操作数向左移动，低位补0
  eg：52>>3;  ----  52向右移动3位
  3.无符号的右位移操作(>>>)：无论正负，都在高位插入0
  4.其他类型使用移位操作符会被强制转换为int，且得到的也是int.
  5.>>=,<<=,>>>=都合法，效果与+=类似。
  6.byte,short类型使用位移操作符会转换为int,然后截断为short或者byte，所以结果可能会出错(可能产生-1的输出结果)。
3.12 三元操作符
  boolean-exp?value0:value1;  ----  如果boolean-exp表达式的结果为true就计算value0的值并返回，反之则计算value1并返回。
  eg：int a = b>c?5:6;  ----  如果b>c则a=5，反之b<c则a=6.
3.13 字符串的+和+=操作
  1.如果表达式以一个字符串起头，那么后续所有操作数都必须是字符型(双引号自动认为是字符串，其他非字符串类型会自动转换为字符串)。
  2.表达式中，有一个字符串，所有变量都会转型为字符串。
3.15 类型转换操作
  1.窄化转换：将能容纳更多信息的数据类型转换成无法容纳那么信息的数据类型。可能面临信息丢失的风险，此时编译器会强制要求进行显示的类型转换。
  2.扩展转换：不必显示的进行转换，因为新类型能容纳所有信息，不会造成信息丢失。
  3.基本类型除了boolean之外都可以互相转换(boolean不允许进行类型转换)。
  4.类数据不能进行类型转换(只能在所属类型的类族之间进行转换)。
  3.15.1 截尾和舍入
    1.在进行窄化转换时需要注意截尾和舍入的问题。在讲double和float转化为int时候，总是会执行截尾操作(直接舍弃小数点后的数据，不论大小)。
    2.如果需要舍入结果，需要调用round()方法。
    3.包含基本类型的运算中(不包括boolean)，整个表达式结果的类型取决于表达式中最大的类型。
    eg：float+double=double
        int+char+long=long
3.16 Java没有sizeof()
  因为java的数据类型在任何情况下都是相同大小，sizeof()没有意义。

第四章，控制执行流程

4.1 true和false
  java中，true不能用1表示，false不能用0表示。java不允许我们将数字作为一个布尔值使用。
4.2 if-else
4.3 迭代
  4.3.1 do-while
    1.do-while:
    do
  	  statement
    while(boolean-statement);
    do-while和while的区别在于，do-while语句中的循环体至少会执行一次，如果条件第一次为false，do内已经正好执行完一次。
  4.3.2 for
  4.3.3 逗号操作符
    用于在for中分割语句，而且语句均会独立执行。
    eg：for(int i=1,j=i+10; i<5; i++,j=i*2){
    		//...
        };
4.4 foreach
  1.foreach不必创建int变量去对由访问项构成的序列进行计数，foreach将自动生成每一项。
  eg：for(float x : f){  ----  x为float数据f中的每一项，在循环体中可以直接对x进行操作。
  	  	    System.out.println(x);
      };
  eg：for(char c : "abchaisuhda".toCharArray()){
            //...
      }
  2.foreach语句广泛用于容器的iterable对象。
4.5 return
4.6 break和continue
  1.while(true)和for(;;)是一回事。
4.7 标签
  1!.Java中没有goto。
  2.break和continue与label的联合使用可以中断多层嵌套的循环。
  eg：
  ...
  outer:  //cannot have statements here , it is a label.
  while(true){
  	  for(;i<10;i++){
  	  	  //...
  	  	  continue outer;  ----  跳转到outer处重新进入循环(外部循环的递增表达式得到执行)
  	  	  //...
  	  	  break outer;  ----  跳转到outer处并且不进入循环
  	  	  //...
  	  }
  }
  3!.一般的continue会退回到最内层循环的开头，并继续执行(执行递增表达式)
  4!.带标签的continue会达到标签的位置，并重新进入紧接着标签后面的循环(执行那个循环的递增表达式)
  5!.一般的break会中断并且跳出当前循环。
  6!.带标签的break会中断并跳出标签所指的循环。
  7.在java中使用标签的唯一理由，就是因为有循环嵌套存在，并且向从多层嵌套中实现跳转。
4.8 switch
  1.switch(a) {
  		case 1:
  		  break;
  		...
  		default:
  		  break;
    }
  2.switch中的a必须是整数值(可以是int,char等整数型)。
  3.break可选，如果每一个case中没有break，则会一直向下执行知道遇到break(可以用在版本更新)。想要对floath或double进行筛选，需要进行if-then或者使用enum类型进行协助。
  4.default后面的break完全没有意义，但是为了代码结构统一，可以加上。

第五章 初始化与清理

5.1 用构造器确保初始化
  1.构造器与类名相同，且在对象初始化时自动调用。
  2.不接受参数的构造器叫做默认构造器(无参构造器)。
  3.构造器是一种特殊类型的方法，因为它没有返回值(这与void不同)，在创建对象时候new表达式返回了对象的引用。
5.2 方法重载
  5.2.1 区分方法重载
    1.使用参数列表的差异(甚至参数列表的顺序不同也可以重载)。
  5.2.2 涉及基本类型的重载
    1.基本类型提升顺序(冒号前为调用时输入的参数类型)：
      (1)constant value: int < long < float < double
      (2)char: char < int < long < float < double
      (3)byte: byte < short < int < float < double
      (4)short: short < int < long < float < double
      (5)int： int < long < float < double
      (6)long: long < float < double
      (7)float: float < double
      (8)double: double
      eg:
      void f1(int x){//...};
      void f1(float x){//...};  ----  在使用f1(5)时候会默认调用f1(int)。
    2.char类型比较特殊，在有明确char类型的参数类型的方法时，使用该方法。没有就当作int，并且遵守int的提升顺序。
    3.较小的类型会提升到相邻较大的方法中。
      eg：
      void f2(float x){//...};
      void f2(double x){//...};
      void f2(long x){//...}  ----  输入int时候会调用long为参数的方法，因为long为int相邻的较大类型。
    4.重载时，编译器能对基本类型进行自动提升，但是不会进行自动窄化，如果没有可以在自动提升后使用的方法，即使存在可以窄化的方法，编译器也会报错。
      eg：
      void f2(short x){//...};  ----  输入为int会报错，不会执行窄化
  !5.2.3 用返回值区分重载方法
    1.用返回值不能区分重载方法，因为有时调用方法不需要返回值也可以调用，在这种情况下编译器无法分辨重载情况。
    eg：
    void f(){//...};
    int f(){//...};
    ...
    int x = f();  ----  可以根据返回值区分
    f();  ----  无法根据返回值区分
5.3 默认构造器
  1.默认构造器形式上就是无参构造器，但是不等于就是。
  2.在一个类没有构造器的时候，编译器会在创建对象时候自动调用默认构造器。
  eg：
  class Bird{}  ----  此类没有构造器
  ...
  Bird bird = new Bird();  ----  编译通过，系统自动调用默认构造器Bird()
  3.如果定义了一个构造器，则系统不会创建默认构造器。
  eg：
  class Bird{
  	Bird(int x){//...};
  }
  ...
  Bird bird = new Bird();  ----  会报错，因为已经定义了构造器，编译器就不会再自动创建默认构造器。
5.4 this关键字
  1.在调用对象的方法的时候，我们使用a.method(x)来进行调用。其实是编译器将对象a也作为参数输入给了方法method(),内部的表示方法为ClassName.method(a,x)--只能这样理解，此语句无法通过编译。
  2.在类内部想要获得对象的引用需要使用this关键字，用来表示调用方法的那个对象的引用。在方法内部调用同一个类的另一个方法无需使用this，直接调用即可。
  3.只在必要的地方使用this，且this只能应用于类的内部。
  eg：
  class Leaf{
  	int i=0;
  	Leaf increment(){
  		i++;
  		return this;  ----  返回本类的引用，此处this为必要。
  	}
  }
  eg：
  class Leaf{
  	void pick(){//...}
  	void pit(){
  		pick();  ----  此处无需使用this.pick()，编译器会自动识别，因为是在本类中调用本类的方法。
  		//...
  	}
  }
  4.this可以用于在类内将自身传递给外部方法。
  eg：
  class Apple{
  	Apple getPeeled(){
  		return Peeler.peel(this);  ----  Peeler.peel()是外部方法，this用作此方法的参数，将自身传递给了外部方法再返回。
  	}
  }
  5.4.1 在构造器中调用构造器
    1.this可以用来在构造器中调用另一个构造器。可以使用this指向自己的数据成员用来与输入参数进行区分。
    eg：
    class Flower{
    	int a = 0;
    	String s = "a";
    	Flower(int num){
    		a = num;
    	}
    	Flower(String s,int num){
    		this(a);  ----  在Flower(String,int)构造器中用this调用Flower(int)构造器(this调用构造器会根据参数列表寻找正确的重载)
    		this.s = s;  ----  使用this.s(数据成员)和s(输入参数)进行区分。经常这样使用。
    	}
    	void flowerMethod(int a){
    		//this(a);  ----  在非构造器内部不允许使用this调用构造器。
    		//...
    	}
    }
  !5.4.2 static含义
    1.static方法是没有this的方法。内部不能调用非静态方法(内部只能使用静态方法，反之非静态方法内部可以使用静态方法是成立的)。因为static方法是不依赖对象的存在的，可以在对象不存在的前提下直接通过类名进行调用，所以内部不能存在依赖对象必须存在的非静态方法。
!5.5 清理：终结处理和垃圾回收
  1.Java垃圾回收器负责回收无用对象占据的内存资源，但是也有特殊情况：假定对象(并非使用new创建)获得了一块特殊的内存区域，垃圾回收器将不知道怎样释放这部分特殊的内存(垃圾回收器只会自动回收由new创建的对象)。
  2.finalize()方法工作原理：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在垃圾回收动作发生时，才会真正的回收对象占用的内存。所以如果调用finalize()就能在垃圾回收发生的时刻做一些重要的清理工作。
  3!.finalize()与析构函数有着本质上的不同(不能用作通用的清理方法)：
    (1)对象可能不会被垃圾回收：只要程序没有濒临储存空间用完的那一刻，对象占用的空间就总也不会得到释放。如果程序结束，没有被释放的对象的空间也会归还被操作系统。所以对象可能不会被垃圾回收，因为毕竟回收垃圾也有一定的开销。
    (2)垃圾回收不等于析构：析构函数中的对象一定会被销毁，但是垃圾回收并不一定会发生。不能保证垃圾回收一定会发生，也不能保证何时发生。
    (3)垃圾回收只与内存有关：finalize()发生在垃圾回收之前，所以其中的操作只应该包括回收垃圾回收器无法回收的对象的操作。但是java一切都是对象，几乎都可以被垃圾回收器回收。这种特殊情况发生在java调用本地代码的时候(java调用C,C++,可能调用的C，C++代码还会调用其它语言的代码，理论上可以调用任何语言的代码)，由其他语言以其他方式分配内存空间时分配的内存。例如C中使用了malloc()在finalize()就要调用free()来释放这些特殊的内存空间。
  5.5.2 java没有析构函数
    1.Java没有析构函数，但是垃圾回收器也不能完全代替析构函数(析构函数的作用不止限于清理对象所占的内存空间)，如果想要发挥析构函数的作用，可以专门写一个方法用来进行析构工作，并且在适当的地方手动调用。
    2.就算没有析构函数，也不能使用finalize()。
  5.5.3 终结条件
    1.finalize()的另一种使用方法：在垃圾回收前对当前对象进行检查(检查对象中时候存在编译器无法找到的逻辑上的遗漏，或者是错误)，以便在垃圾回收发生的时候(不可预期)将潜在的错误通过finalize()方法突显出来。因为有时这种错误是极难发现的。
    eg：P89
    2.调用System.gc()会强制进行垃圾回收和执行finalize()方法。
    3.在编写finialize()时，不要忘记super.finalize()，因为基类可能存在已经定义好了的关于finalize()的内容。
  !!5.5.4 垃圾回收器工作原理
    1.在堆中分配对象开销高昂，在堆栈中分配对象会更快。但是java有垃圾回收器使得对象分配在堆上的速度与在堆栈上向媲美。因为java虚拟机的堆实现不同，堆指针单纯的指向未被分配的空间，且垃圾回收器将一面回收空间，一面使堆中的对象紧凑排列。通过垃圾回收期对对象重新排列，实现了一种高速的，有无限空间可供分配的堆模型。
    2.几种垃圾回收机制：
      (1)引用计数：简单但是速度很慢。每一个对象都有一个引用计数器，当有引用连接至对象时，引用计数+1。当引用离开作用域或被置为null时，引用计数-1。垃圾回收期会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，释放其占用空间。但是当对象之间存在循环引用时，可能会出现对象应该被回收，但是引用计数不为0的情况。处理这种情况的工作量极大。一般没有用于任何一种java虚拟机中实现。
      (2)发现活的对象的方法：因为所有活的对象最终一定能追溯到其存活在堆栈或者静态区之中的引用(创建的各种类最终都会从基本类型，或者静态变量开始引用)。所以从静态和堆栈区开始遍历所有引用，对于发现的每个引用，追踪它所引用的对象，然后此对象包含的所有引用，反复进行，直到从堆栈和静态区出发遍历的引用都被全部访问为止，访问过的对象都是活的，那些没有被遍历到的(没有引用指向的)就是垃圾。
      (3)停止-复制：先暂停程序的运行(不属于后台回收模式)，然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。当复制到新堆的时候，它们是一个挨着一个的，所以新堆保持紧凑排列。复制时，引用会被修正，堆栈和静态区的引用直接修正，其他对象会在遍历过程中进行修正。
      (4)标记-清扫：先暂停程序的运行(不属于后台回收模式)，每找到一个存活的对象就设一个标记，这个过程中不会回收。只有当所有对象都标记完成时，才开始清理，没有被标记的对象的内存就会被释放。所以剩下的空间是不连续的。如果需要得到连续的空间的话，需要重新整理剩下的对象。速度相对慢
      (5)自适应分代垃圾回收器：单纯的停止-复制效率降低。因为需要有两个堆，比实际维护的空间大一倍。处理方法是在堆中分配几块较大内存，然后来回倒腾。而且程序进入稳定之后，只会产生少量垃圾甚至没有垃圾，却仍然将所有内存从一处复制到另一处，浪费。所以在只产生少量垃圾时候便使用标记-清扫方式(在垃圾少的时候较快)。具体执行：
        (1)内存分配以较大的块，如果对象较大则占用单独的块，也有专门放置小对象的块。
        (2)每个块有相应的代(generation)数来记录是否存活，通常情况下如果某处的块被引用，则代数+1。
        (3)垃圾回收器会定期进行完整的清理：大型块不会被复制而是代数增加，内含小型对象的块则会被复制并整理。
        (4)java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器效率降低，则切换到标记-清扫方式。同样如果标记-清扫在堆空间中产生很多碎片空间，则切换回停止-复制以获得连续紧凑的内存空间。
    3.JIT技术：即时编译器技术。即使编译器只在必要的时候才编译代码，这样从不会执行的代码也许压根就不会被JIT编译。
5.6 成员初始化
  1.java应该尽量保证所有变量都得到初始化，在创建的时候。
  2.在局部变量中，没有初始化的变量编译器会报错。
  eg：
  void f(){
  	int i;
  	i++;  ----  编译器报错，局部变量未被初始化
  }
  3.类的数据成员，没有初始化会被赋予初始值，用来保证整个对象的顺利运行。(具体默认值参考本笔记2.2.2)
  4.在类里定义一个对象引用时，如果不初始化，此引用会得到一个null。
  5.6.1 指定初始化
    1.在类中想要为数据成员进行初始化，基本类型可以在字段后面直接=想要的数据，对象可以在后面直接new一个新对象。这两者也都可以通过一个方法的返回值来指定初始化，其中该方法的参数必须是初始化了的。
    eg：
    class InitialValue2 {
    	boolean bool = true;
    	byte b = true;
    	int i = 999;  ----  基本类型可以直接进行指定初始化。
    	Depth depth = new Depth();  ----  对象通过new关键字进行制定初始化。
    	int i2 = g(i);  ----  也可以通过方法返回值进行制定初始化，但是其中的参数必须经过初始化。
    	int g(int n){return n*10}
    }
    2.指定初始化创建出来的类，每一个类都具有相同的初始化值。
5.7 构造器初始化
  1.将初始化过程放在构造器中，在对象创建的同时，根据输入参数进行相应有针对性的初始化。
  2.构造器初始化无法阻止指定初始化。(对象创建的时候会先进行指定初始化，然后进根据构造器进行初始化)
  3!.在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量的定义不止在字段，还分布于构造器和不同方法之间(并不是在方法之内)，这些初始化语句也总是能在任何方法和构造器运行之前得到初始化。
  eg：
  class House {
  	Window w1 = new Window(1);
  	House() {
  		w3 = new Window(4);
  	}
  	Window w2 = new Window(2);
  	Window w3 = new Window(3);
  }  ----  初始化顺序：w1,w2,w3(3)，然后再在构造器中对w3进行再一次的初始化w3(4)，之前的对象会被当作垃圾，w3的引用会指向新对象。注意这里是当w1,w2,w3都初始化完毕之后再执行构造器中的初始化。
  5.7.2 静态数据的初始化
    1.无论创建多少个对象，静态数据都只占用一份存储区域。
    2.创建在静态域中的基本类型没有得到初始化，会获得基本类型的相应的默认初始值。如果在静态区的对象没有得到初始化，则会得到一个null。
    3?.静态成员的初始化只在必要的时候才执行。
    4.静态成员和非静态成员都需要初始化时，静态成员先初始化，但是只初始化一次。
    5.虽然没有static关键字，但是构造器数据静态方法。
    6!.对象的创建过程：
      (1)当创建的类创建，或者需要被访问的时候，会查找类路径，定位.class文件
      (2)载入.class文件(创建一个Class对象)，在这时有关所有静态初始化的所有动作都会执行。因此静态初始化值在Class对象首次加载时进行一次。
      (3)当使用new关键创建该对象时，先在堆上为此对象分配足够的存储空间,并将其储存空间请0。
      (4)自动将此类中的所有基本类型都置为默认值，对象的引用则置为null。
      (5)执行所有出现在数据成员的制定初始化操作(这就是为什么非静态成员初始化在静态初始化后面)。
      (6)执行构造器，其中可能会牵涉更多动作，尤其是在涉及继承的时候。
  5.7.3 显式的静态初始化
    class Name{
      static{  ----  此处{}内为一个语句，其中的任何操作都为静态操作，只在类创建的时候执行一次(就算其中含有不会存储在静态区的语句也只会执行一次)
        new Cup();
        new Apple();
      }
    }
  5.7.4 非静态实例初始化
    {
      //...  ----  只比static用法少了一个static关键字
    }
!5.8 数组初始化
  1.数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或者基本类型数据序列。
  2.数组的定义：
    int[] a1;
    int a1[];
  3!.编译器不允许指定数组(引用，等号左侧)大小！！因为创建的是一个引用，已经为引用分配了储存空间，如果想指定数组的储存空间，则需要对数组进行初始化。
  4.数组的初始化：
    int[] a = {1,2,3,4,5};  ----  等价于使用new
  5.一个数组可以赋值给另一个数组,但是复制的引用。这以为这修改其中一个数字，复制的另一个也会发生改变。因为两个引用都指向一个数组。
  6.数组有一个默认的属性,length。数组从0开始，最大的访问元素是length-1。
  7.在不知道数组有多少个元素的时候，可以使用new关键字创建确定size的数组对象，如果不进行内部数据初始化的话，则会将全部数组成员初始化为默认值(仅限基本类型)。
  eg：
  int[] a = new int[size];  ----  size为数组的元素个数。可访问元素最多为size-1。
  8.在用对象生成的数组中，如果只创建了引用，不进行初始化的时候使用数组中的对象则会编译器报错。
  9.可以在初始化数组的时候也进行数组内对象的初始化。
  eg：
  Integer[] a = new Integer[]{
    new Integer(1),  ----  在初始化的过程中，对数组中的对象进行初始化。
    new Integer(2),
    3
    ,  ----  列表中的最后一个逗号可选，即使存在也可以通过编译
  }
  也可以这样用：
  eg：
  apple.useArray(new String[]{"heiheihie","hahaha"});  ----  在必要的时候可以直接创建数组对象，不需要使用引用。
  10.打印数组的时候需要使用printArray()函数，输入参数为各种类型的数组，会对不同对象的toString()进行打印。
  5.8.1 可变参数列表
    1.所有对象都继承自Object，可以创建Object数组，就可以存放多种不同的对象。
    eg：
    Object[] obj = new Object[]{new Integer(1),new Float(2),new Double(2.3)};
    for(Object x:obj){  ---- 可以通过foreach语法对每个数组对象进行操作。
      System.out.println(x);
    }
    2.JRE1.5可以时候可变参数列表
    eg：
    static void f(String... name){  ----  ...不是省略号，是新语法，用来表示name是一串类型为String的列表(可以在输入参数中逗号分隔，作为正常的输入参数使用)，在函数体中庸foreach语法进行调用。
    	for(String x:name){
    		System.out.print(x);  ----  用foreach即可实现对可变参数列表的逐个操作。
    	}
    }
    可变参数列表可以使用Object...以达到输入任何对象类型的参数列表。
    3.可变参数列表可以使用任何类型的对象，包括基本类型(在Object中只能使用包装类)。
    4.可变参数列表会使函数的重载变得复杂，可以在可变参数列表前面添加一个非可变参数列表进行区别，或者压根不使用可变参数列表。
    5.在一个函数名的多个重载版本中，应该最多使用一个含有可变参数列表的重载函数，或者压根不用。
5.9 枚举类型
  1.enum类型的定义方法：
  eg：
  public enum Spiciness{  ----  给enum类制定一个名称
  	NOT,MILD,MEDIUM,HOT,FLAMING  ----  此enum类的成员(无需关注其类型，其实就是常量)
  }
  public class EnumOrder{
  	public static void main(String args[]){
  		Spiciness howHot = Spiciness.HOT;  ----  enum类成员的调用
  		System.out.println(howHot);  ----  对enum对象打印，会引起其成员的名称，此句的输出为HOT
  	}
  }
  2.enum的两个方法，EnumName.values()返回enum类中的所有成员组成的序列(可以通过foreach访问)，.ordinal()返回某个enum成员在enum类中的序号。
  eg：
  public class EnumOrder{
  	public static void main(String[] args){
  		for(Spiciness s:Spiciness.values()){  ----  Enum.values返回Spiceness类型的数组，数组成员为所有enum类中定义的enum值，可以通过foreach进行访问
  			System.out.print(s.ordinal()+",");  ----  .ordinal()可以返回当前enum成员在enum类中的顺序(就是一个常量)，此输出为0，1，2，3，4，
  		}
  	}
  }
  3.作为类的属性，与switch连用。
  eg：
  class Name{
  	public Spiciness howHot;  ----  在类中以enum的类型定义一个变量作为类的属性，可以在构造器或者其他部分中对其进行初始化。
  	...
  }
  switch(name.howHot){  ----  根据enum的不同值，通过switch对其进行不同的操作。
  	case NOT:
  		break;
  	case MILD:
  		break;
  	case MEDIUN:
  		break;
  	case HOT:
  		break;
  	case FLAMING:
  		break;
  	default:
  		break;
  }
  4.enum确实是类并且有自己的方法。

!第六章 访问控制权限

6.1 包：库单元
  1.每一个java文件叫做一个编译单元，每一个编译单元后面必须有一个.java后缀，编译单元内可以有一个public类，该类的名称必须与文件名相同(包括大小写)，每个编译单元只能有一个public类，否则编译器不会接受。如果在该便宜单元之中海油其他类的话，在包之外的世界是无法就看见这些类的，因为他们不是public类。
  2.当考虑到正在准备编写对在同一机器上共存的其他java程序友好的类库或者程序的话，就需要考虑如何防止类名称之间的冲突问题。
  6.1.1 代码组织
    1.每编译一个.java文件，在.java文件的每个类都会有一个输出文件，而该输出文件的名称与.java文件中的每个类都相同，但是多了一个后缀.class。Java可运行程序是一组打包并压缩为一个JAVA文档文件的.class文件。
    2.package语句，使用package语句，声明你的这个类在此package中，必须书写在除注释外的第一行,package语句的所有字母都为小写。
    eg：package access.mypackage  ----  将要书写的类在access.MyClass包下
    3.可以使用完整的包名，或者使用import导入包。
    eg：access.mypackage.MyClass myClass = new access.mypackage.MyClass();  ----  通过出入完整的包名来使用该类
    eg：
    import access.mypackage.*  ----  *为通配符，表示使用mypackage包下的所有类。
    MyClass myClass = new MyClass();  ----  通过import导入来使用类。
  6.1.2 创建独一无二的包名
    1.按照惯例，package名称的第一部分是类的创建者的反顺序的Internet域名。
    2.如果没有域名，可以将包分解为你机器上的一个目录，或者以自己的名字进行命名。
    3.将包的路径添加到CLASSPATH(全局路径)时，在任何地方的.java文件都可以使用包中的类(.jar文件需要具体指明文件夹中的.jar的名称)。
  6.1.3 定制工具库
    1.可以将自己写的工具类的目录加入到环境变量中，然后就可以在任何java程序中进行调用了。
    2.工具类可以包括，定制自己的print函数等，经常用到的并且可以简化的操作。
  6.1.4 用import改变行为
    1.C中的条件编译是为了跨平台而存在的，java中没有条件编译，因为所有机器都运行在JVM上所以，java没有条件编译。
  6.1.5 使用包的忠告
    1.无论何时创建包，都已经在给定包名称的时候隐含的制定了目录结构。这个包必须位于其名称所制定的目录之后，而该目录页必须是在以CLASSPATH开头的目录中可以查询的到的。
!6.2 java访问权限修饰词
  1.private,public,protected,包访问权限
  6.2.1 包访问权限
    1.如果不提供任何访问权限修饰词，则为包访问权限(也可以表示为friendly)。意味着当钱包中的所有其他类对那个成员都有访问权限，但是对于包外，则是private。
  6.2.2 public：接口访问权限
    1.public之后紧跟着的成员声明自己对每个人都是可用的。
    eg：
    package access.dessert;
    public class Cookie{
    	public Cookie(){
    		//...
    	}
    	void bite(){
    		//...
    	}
    }
    ~~~~
    import access.dessert.*;
    public class Dinner{
    	public static void main(String[] args){
    		Cookie x = new Cookie();  ----  可以访问，因为构造函数和类都是public。
    		//x.bite();  ----  无法访问因为是包访问权限，只能在包内部访问。
    	}
    }
    2.在同一个目录下，并且没有声明package名的.java文件可以互相提供包访问权限，因为编译器会自动将他们算作同一个目录中的默认包之下。
  6.2.3 private：无法访问
    1.private意思是除了包含该成员的类之外，其他任何类都无法访问这个成员。
    eg：
    class Sundae(){
    	private Sundae(){}
    	static Sundae makeASundae(){
    		return new Sundae();
    	}
    }

    public class IceCream{
    	public static void main(String[] args){
    		//Sundae x = new Sundae();  ----  无法访问，将构造器设为private可以防止其他人随意调用构造器，并且也可以阻止对该类的继承。
    		Sundae x = Sundae.makeASundae();  ----  只能通过这种方法获取Sundae的实例。
    	}
    }
    2.任何可以肯定只是该类一个助手方法的方法，都可以设为private，因为可以确保在包内的其他地方误用到它。
    3.除非必须公开底层细节，否则应该将所有的域都制定为private。但是不能因为在类中对某个对象对的引用是private，就认为其他的对象无法拥有该对象的public引用。
  6.2.4 protected：继承访问权限
    1.如果创建了一个新包，并自另一个包中继承一个类，那么唯一可以访问的成员就是源包中的public成员。而当希望有某个成员，吧他的访问权限赋予派生类而不是所有类的时候，就用protected修饰。而protected也提供包访问权限，相同包内的其他类可以访问protected。
    eg：
    package access.cookie2;
    public class Cookie{
    	public Cookie(){}
    	protected void bite(){}
    }
    ~~~~
    import access.cookie2;
    public class Chocolate extends Cookie{
    	public Chocolate(){}
    	public void chomp(){
    		bite();  ----  可以访问，因为Chocolate是Cookie的子类。但是其他非包内类无法访问。
    	}
    }
6.3 接口和实现
6.4 类的访问权限
  1.class之前只能用public(对于任何人都可以使用该类)，或者不加修饰词(包访问权限，只有包内类可以使用该类)--内部类除外。
  2.如果不希望任何人使用该类，则可以把所有的构造器都设置为private，但是例外是，该类的static成员内部可以创建该类private的构造器。用static方法创建获取private构造器对象实例的方法有两种：
  	(1)在static方法中new一个对象，对于控制对象的个数有帮助。
    eg：
    class Soup1{
    	private soup1(){}
    	public static Soup1 makeSoup1(){
    		//...  ----  可以在此处添加创建对象之前的工作，平常情况下，程序员直接new一个新对象的话，是无法在new对象之前进行操作的(构造器内的操作是创建对象之后)
    		return new Soup1();
    	}
    }
    ~~~~
    Soup1 soup1 = Soup1.makeSoup();  ----  可以通过该方法创建多个soup1对象，可以轻易的在创建对象之前进行static方法中的其他操作。
    (2)!单例模式，即只能创建该类的一个对象。
    eg：
    class Soup2{
    	private Soup2(){};
    	private static Soup2 soup2 = new Soup2();  ----  在该类得到访问的时候只初始化一次。
    	public static Soup2 access(){
    		return soup2;
    	}
    	public void f(){}
    }
    ~~~~
    Soup2.access().f();  ----  永远只能对唯一的该类的对象进行操作。这种情况非常有用。
  3.如果该类的某个static成员时public的话，则客户端程序员依旧可以调用该static成员，尽管他们并不能生成该类的对象。

!!第七章 复用类

  1.复用类代码有两种方式：
    (1)组合：只需要在新的类中产生现有类的对象。
    (2)继承：按照现有类的类型来创建新类，无需改变现有类的形式。
7.1 组合语法
  1.toString()方法：所有非基本类型对象都有的方法，当编译器需要一个String，而你却只有一个对象时，该方法便会被调用。需要使用此功能时，在类中写一个toString()方法即可。
  2.组合语法中，现有类的初始化方式：
    (1)在定义对象的地方(字段处)直接初始化，意味着在构造函数之前就会被初始化。
    (2)在类的构造器中。
    (3)惰性初始化：在正要使用这些对象之前。在生成对象不值得并且不必要每次都生成对象的时候，这样做可以减少负担。
    (4)使用实例初始化。
7.2 继承语法
  1.在创建一个类的时候，总是在继承。除非明确指出要继承的类，否则默认继承自Object。
  2.用extends关键字进行继承，在执行此操作时，默认得到基类中所有的域和方法(可以用导出对象进行调用，尽管没有再导出类中进行显示的定义)。
  3.可以为每一个类创建一个main()函数，这种方法用于测试每一个类非常方面。在运行程序时候，命令行中运行的是哪个类就会调用那个类的main()函数。
  4.同一个包中，一个类继承另一个类，可以获得基类中所有含有包访问权限的方法，但是当包外类继承该导出类的时候，却不能访问基类中的包访问权限的方法。所以为了继承，一般的规则是将所有数据成员都制定为private，将所有的方法都定义成public(也可以用Protected)。
  5.java用super表示超类，表示当前类是从超类继承来的。可以使用super.method()来调用基类中的方法。
  7.2.1 初始化基类
    1.java会自动调用基类的构造器，当运行导出类的构造器的时候。(导出类没有构造器的时候，会使用默认构造器，其中也包括基类的构造器)。
    eg：
    class Art{
    	Art(){ System.out.println("art")};
    }
    class Brt extends Art{
    	Brt(){ System.out.println("Brt")};
    }
    class Crt extends Brt{
    	Crt(){ System.put.println("Crt")};
    }
    ...
    Crt crt = new Crt();  ----  输出：art\nbrt\nvrt\n
    2.如果基类没有默认构造器(没有无参数的构造器)，则需要使用super进行对基类构造器的显式调用，还要配上对应的参数，并且显式调用构造器是在导出类的构造器中的第一件事(写在第一行)。
    eg：
    class A{
    	A(int i){}
    }
    class B{
    	B(int i){
    		super(i);  ----  必须显式的调用A构造器。如果不调用编译器则会报错。
    		//...
    	}
    }
7.3 代理语法
  1.在新类中就以组合的方式声明创建一个类，然后将其所有方法以代理的方式写入底层。
  eg：
  public class Controller{
  	void up(int i){}
  	void down(int i){}
  	...
  }
  public class Me{
  	private Controller controller = new Controller();
  	void up(int i){
  		controller.up(i);  ----  虽然使用组合方式使用了Controller类(本应该隐藏此类在新类中的辅助工作)，但是还是暴露了Controller的实现，并且将其方法置于底层。
  	}
  	void down(int i){
  		controller.down(i);
  	}
  }
  2.代理方式可以对使用的类进行控制，可以选择性的暴露其方法给外界。
  3.继承也将会暴露基类的所有方法给外界，但是无法做到代理方式的选择性暴露(拥有更多控制力)。
  4.java对代理没有直接语法上的支持，但是通过类的构建可以自己手动实现。
7.4 结合使用组合和继承
  7.4.1 保证正确清理
    1.如果有多个对象相互依赖的创建时，如果需要手动清理，请按照对象创建的反顺序调用每一个对象的清理方法。
  7.4.2 名称屏蔽
    1.当java基类中有一个方法名被多次重载时，在导出类中的重新定义该方法名称并不会屏蔽基类中的任何版本(导出类中的重载版本与基类中的重载版本一同生效)。
    eg：
    class A{
    	void fun(int i){}
    	void fun(char c){}
    }
    class B extends A{
    	void fun(float f){}
    }
    ...
    B b = new B();
    b.fun(1);
    b.fun('a');
    b.fun(3.4f);  ----  所有方法都会生效，但是所有的重载版本却分布在基类和子类中。
    2.在子类中对基类中的方法完全相同的特征签名以及返回值的重载，叫做覆写(很经常的操作)，需要使用@Override在函数定义之前进行声明(非必要)。
    class C extends B{
    	@Override
    	void fun(float f){}  ----  对基类的覆写。
    }
!7.5 在组合和继承中选择
  1!.组合和继承都允许在新的对象中放置子对象，组合式显式(显式创建对象，但却期望隐藏起在类中的具体作用)这样做的，而继承则是隐式这样做的。组合技术通常用于在新类中使用现有类的功能而非它的接口的时候。新类用户看到的也只是新类所定义的接口，而非所嵌入的对象。
  2!.继承的时候，是使用某个类，并开发它的特殊版本。通常意味着，你需要使用一个通用类，但是为了某种特殊需要而将其特殊化。
7.6 protected关键字
  1.protected：对继承与此类的导出类，或者存在于同一个包中的类提供权限。
  eg：
  class A{
  	private String name
  	A(String name){
  		this.name = name;
  	}
  	protected void change(String name){
  		this.name = name;
  	}
  }
  class B extends A{
  	private int age;
  	B(String name,int age){
  		super(name);
  		this.age = age;
  	}
  	void change(String name,int age){
  		set(name);  ----  可以在子类中使用
  		this.age = age;
  	}
  }
7.7 向上转型
  1.子类与基类的关系：继承出来的类是基类的一种类型。
  2.子类可以视作与基类同样的类型(在需要基类的参数列表中，子类一样可以传入)，因为可以发送给基类的消息，子类全部都能接受(子类包含了基类中的全部实现)。称作向上转型
  eg：
  class Instrument{
  	void play(){}
  	static void tune(Instrument i){
  		i.play();
  	}
  }
  class Wind extends Instrument{
  	public static void main(String[] args){
  		Wind wind = new Wind();
  		Instrument.tune(wind);  ----  可以运行
  	}
  }
  7.7.1 为什么称为向上转型
    1.在继承图中是向上移动的。
    2.在向上转型发生时，只会丢失方法，不会获得新方法。
    3.允许向下转型(不安全)，但是需要额外操作。
  7.7.2 组合与继承
    1.继承并不是常用的手段，并不应该尽量使用继承
    2.是选择组合还是继承时，问一问自己：自己到底是否需要向上转型？如果需要则继承是必要的。
7.8 final关键字
  7.8.1 final数据
    1.被final修饰的数据是不会改变的数据，编译器可以将常量值代入任何可能用得到它的地方。
    2.final必须是基本类型，定义时就必须对其进行赋值。
    3.被static,final同时修饰的词会占据一快不会改变的内存空间。
    4!.对对象同样也可以使用final，但是意义不用，对对象使用final，表示该引用只能指向该对象(引用的方向是final，但是对象内部仍然可以改变)。此法则对数组也同样有效，因为数组也是对象。
    5.空白final，指的是被声明为final但是未给定初值的域，但是必须保证其在使用前的初始化。
    eg：
    class A{
    	private final int a;  ----  空白final，并没有赋值
    	A(int a){
    		this.a = a;  ----  在构造器中对其进行初始化，以保证在使用a时，a已经初始化了。
    	}
    }
    这样可以做到final的值根据每个对象而不同，但是却还保持这无法改变的特性。
    6.final参数，在参数列表中对输入参数声明为final：
      (1)当final修饰参数列表中的对象时：表示你无法在方法中更改参数引用所指向的对象。
      (2)当final修饰参数列表中的基本类型是：你无法在方法中修改，而只能读取。(常用于向内部匿名类传递数据)
      eg：
      void f(final Book book){
      	//book = new Book();  ----  错误，book是final，无法将引用指向其他对象
      	book.read();  ----  编译通过，引用无法指向其他对象，但是对象本身可以随意操作。
      }
      void g(final int a){
      	//i++;  ----  错误，无法修改a值
      	int b = a+1;  ----  编译通过，因为只进行了读取操作。
      }
    7.8.2 final方法
      1.使用final修饰方法的原因有两个：
        (1)设计：类中被final修饰过的方法，禁止被子类覆写。
        (2)效率：被final修饰的方法，编译器将会吧代码以副本的形式进行处理，直接插入到源代码中(普通的函数操作需要通过指针进行各种跳转，类似于C++中的inline)，现在该功能已经被弃用，相应的优化操作由JVM自动进行。
      2.类中所有private方法都隐式的指定为final的。(在子类中其实是可以对基类中的private或者private final方法进行“覆写”的，但是其实只是隶属于不同类中的两个相同名称的方法，因为private本身就不属于接口)。
    7.8.3 final类
      1.一个类整体被定义为final时(final class A{...})，表示你不打算继承该类。原因可能是你觉得该类不需要做出变动，或者处于安全考虑。
      2.final类中的域，并不是final的如果需要是final需要手动定义为final.
      3.final类中的方法，都是默认为final的，因为类无法被继承，所以方法也是不能被覆写的。
    7.8.4 使用final的忠告
      1.类的复用无法正确预测，请想好再使用final关键字。
7.9 初始化及类的加载
  1.在访问一个具有继承关系的类的时候，编译器的初始化顺序：
    (1)找到该类的编译代码(.class文件)。
    (2)如果在加载过程中发现该类有基类(extends)，于是会继续加载基类(不管你是否打算产生一个基类对象)。并且如果基类还有基类，加载将会继续向上进行。
    (3)当所有具有继承关系的类都加载结束的时候，基类中的static数据开始加载，然后是导出类的static数据加载。(如果是多层继承关系，则从上到下加载各个层次的static数据)。
    (4)当所有具有继承关系的static都加载完毕之后，对象就可以被创建了。首先对象中的所有基本类型都会被设置成默认值，引用对象为null。
    (5)基类的构造器开始调用(可以默认调用，也可以使用super进行显式调用)。
    (6)实例变量按次序进行初始化。
    (7)需要创建的对象的构造器(的后半部分)得到执行。

第八章 多态

8.1 再论向上转型
  1.当方法中的参数列表是基类时，输入参数为导出类，在方法体中，编译器可以正确的根据类型调用导出类的相应方法(而不是基类的)。这种情况叫做多态(导出类被当作基类类型使用，但是却会调用导出类的方法)。
  2.方法调用绑定：将一个方法调用同一个方法主体关联起来叫做绑定。
    (1)前期绑定：在程序执行前进行绑定。(由编译器和链接程序实现，多用于面向过程的语言)
    (2)后期绑定(动态绑定，运行时绑定)：在程序运行时能判断对象的类型，从而恰当的调用方法。
  3.java中除了private和final修饰的方法(不能覆写的方法)外，其余方法都默认为后期绑定方式，并且会自动发生。
  eg：
  Shape s = new Circle();
  s.draw();  ----  如果Shape类和Circle类都有.draw()方法，此处会调用Circle对象的方法，尽管声明的引用是Shape类型的。(Circle就是一种Shape)
  4.大多数类都会遵循这种模式：基类定义好接口，导出类进行具体实现(覆写基类的方法)，然后只需要通过与基类进行通讯，就可以正确的调用导出类的方法。这样的程序设计也是可扩展的，因为可以从基类中继承出很多新类型，而不用修改任意其他导出类中的代码。
8.2 转机
  8.2.4 缺陷：“覆盖”私有方法
    1.public class A{
    	private void f(){//...}  ----  声明为private的方法，不允许被覆写
    }
    class B extends A{
    	private void f(){//...}  ----  虽然很像覆写了基类的私有方法，但是其实两个方法分别是两个类中的私有方法。所以不会报错
    }
    2.只有非private和非final才能覆写。
  8.2.5 缺陷：域与静态方法
    1.多态只发生在方法的调用中，如果想访问域(数据成员)，则不存在多态。
    eg：
    class Super{
    	public int field = 0;
    }
    class Sub extends Super{
    	public int field = 1;
    }
    ...
    Super super = new Sub();
    Sub sub = new Sub();
    System.out.println(super.field);  ----  输出是0，如果这里是调用的方法则会调用Sub中的方法，但是直接访问域，则会返回基类(引用类型)的域值
    System.out.println(sub.field);  ----  输出是1，因为本来要访问的就是导出类。
    2.静态方法没有多态
    eg：
    class Super{
    	public static void f(){
    		System.out.println("super static");
    	}
    	public void g(){
    		System.out.println("super non-static");
    	}
    }
    class Sub extends Super{
    	public static void f(){
    		System.out.println("sub static");
    	}
    	public void g(){
    		System.out.println("sub non-static");
    	}
    }
    ...
    Super super = new Sub();
    super.f();  ----  输出“super static”，因为静态方法不会进行多态(会按照引用类型进行调用方法)
    super.g();  ----  输出“sub non-static”，非静态方法调用会进行多态(按照new后面的类型进行调用方法)
    因为静态方法是与类，而非单个方法进行关联的。
8.3 构造器与多态
  1.构造器不具有多态，因为是隐式的static方法。
  8.3.1 构造器的调用顺序
    1.调用顺序(并不适用于所有情况)：
      (1)调用基类构造器，如果有多层继承，则从最根部的基类开始执行构造器，直到该导出类的相邻的上一层。
      (2)数据成员的初始化。
      (3)调用该导出类的构造器。
  8.3.2 继承与清理
    1.虽然通常情况下不必进行清理工作，但是一旦选择在类中写一个清理方法，则要记得覆写基类的dispose()方法并且在其中调用super.dispose()。
    2.如果成员中存在一个对象或者数据成员被多个该对象持有(static)，则在清理时需要注意。应该使用引用计数法进行清理。
  8.3.3 构造器内部的多态方法的行为
    1!.构造器中对方法进行调用，会遵循多态行为，但是如果本构造器是该对象的某层导出类的构造器(也就是说本构造器的运行只是构建最终对象的一部分，而不是结束)，则在次构造器中调用本基类的方法时，方法会调用底层还未执行构造器的导出类的方法，因为该导出类还未被正确初始化，则可能会引发错误的调用。
    eg!：
    class A{
    	void draw(){ System.out.println("A.draw()"); }
    	A(){
    		System.out.println("A() before draw()");
    		draw();  ----  虽然在基类构造器中，但是会调用导出类的方法
    		System.out.println("A() after draw()");
    	}
    }
    class B extends A{
    	private int num = 1;
    	void draw(){ System.out.println("B.draw()"+num);}
    	B(int num){
    		this.num = num;
    		System.out.println("B()"+num);
    	}
    }
    ...
    new B(5);
    输出结果为：
    A() before draw()  ----  基类构造器的调用
    B()0  ----  在基类的构造器中调用了方法，这里执行多态，所以会执行导出类的方法B.draw()，但是因为这时候B的private int num还没有初始化为1，所以显示了错误的默认初始值0
    A() after draw()
    B()5  ----  到这里，B对象才执行构造器，并且private int num得到正确初始化与赋值，所以这里是正确赋值的5
    2!.完整的初始化顺序：
      (1)在其他任何事物发生之前，将分配给对象的储存空间初始化成二进制的0，引用则为null
      (2)调用基类构造器(如果基类中存在方法调用，则会调用导出类的方法，执行多态，因为上一步，所以字段部分都是0可能带来错误的调用)
      (3)按照声明顺序调用成员的初始化方法
      (4)调用导出类的构造器方法
    3!.构造器的设计准则：
      (1)用尽可能简单的方法进入正常的状态，构造器中尽量避免调用其它方法。
      (2)如果构造器中必须调用，则可以调用private或者final方法，因为这些方法不会被覆写。
8.4 协变返回类型
  1.导出类中被覆盖的方法可以返回基类方法的返回类型的某种导出类型。
  eg：
  class A{
  	A process(){return this;}  ----  返回A
  }
  class B extends A{
  	B process(){return this;}  ----  虽然覆写A中process()方法，但是返回类型可以是基类中返回类型的子类(在这里就是B)
  }
8.5 用继承进行设计
  1.当我们使用现成的类来建立新类时，如果首先考虑使用继承技术，则反倒会加重我们的设计个负担。
  2!.更好的方式是首先选择“组合”，尤其在不确定使用哪一种的时候，因为组合更灵活，可以动态的选择类型。相反继承则在编译时就要知道确切的类型。
  状态模式：
  eg：
  class Actor{
  	public void act()
  }
  class HappyActor extends Actor{
  	public void act()
  }
  class SadActor extends Actor{
  	public void act()
  }
  class Stage{
  	private Actor actor = new HappyActor();  ----  此对象可以不断被替换，作为此类的状态，这种设计方式更灵活
  	private void change(){ actor = new SadActor; }
  	public void performPlay(){ actor.act(); }
  }
  ...
  Stage stage = new Stage();
  stage.performPlay();
  stage.change();
  stage.performPlay();
  随着actor状态的改变，performPlay()的运行方式也会改变。
  3.用继承表达行为间的差异，并用字段表达状态上的改变。
  8.5.1 纯继承与扩展
    1.有时采取纯继承的方式非常有用，即基类确定了所有接口，子类对接口的数量不做改变，并一一覆写(is-a)。这种情况下继承可以确保所有的导出类具有基类的接口，而且导出类可以完全代替基类。
    2.有时需要用扩展继承的方式，即除了覆写了基类的接口之外，子类还自身扩展了其他接口。但是缺点就是导出类中的额外接口部分不能通过基类来访问，必须确定具体的子类类型。因此一旦向上转型就无法使用这些接口。
  8.5.2 向下转型与运行时类型识别
    1.向下转型，将基类类型制定为一个具体的子类(其实就是类型强制转换)，在对象前面加上括号，括号里面写上需要强制转换的类型即可。
    2.RTTI：运行时类型识别，在运行期间对类型进行检查，如果类型不对则返回一个ClassCastException
    eg：
    class A{
    	public void f(){}
    }
    class B extends A{
    	public void f(){}
    	public void g(){}
    }
    ...
    A a = new A();
    A b = new B();
    a.f();
    //b.g();  ----  A中无法调用B中的扩展接口，即使实际的对象是B
    (B)b.g();  ----  向下转型以使用B的扩展接口 
    (B)a.g();  ----  Exception Throw(进行转型时使用了错误的类型)
    3.RTTI还提供了一种方法，使你可以在向下转型之前查看你要处理的类型。(后面会讲到，我现在也一脸懵逼)

!第九章 接口

!9.1 抽象类和抽象方法
  1.抽象类，一种普通类与接口之间的中庸之道
  2.抽象方法：当一个类(基类)的作用只限于为其子类提供接口的时候，此类的任何方法没有任何意义，也不需要任何实现，甚至应该阻止程序员调用这些方法(应该利用多态调用其子类覆写的方法)。这样的方法可以定义为抽象方法，对其进行调用会返回错误：
  abstract void f()
  3.抽象类：含有一个或者多个抽象方法的类叫做抽象类，含有抽象方法的类必须声明为抽象类，不然会报错。但是成为抽象类并不意味着所有的方法都是抽象的(也可以包含某些方法的具体实现)
  4!.如果从一个抽象类继承，并向创建该新类的对象，那么就必须为基类中所有抽象方法(非抽象方法可以不算)提供定义方法(必须对所有抽象方法进行覆写)。如果不这样做(也可以不这样做)，那么导出类便也是抽象类，且编译器会强制用abstract来修饰这个类。
  abstract class A{...}
!9.2 接口
  1.接口更加抽象，接口(interface关键字)产生一个完全抽象的类，根本没有任何实现。接口允许穿不暖关键这确定方法名，参数列表，返回类型，没有任何方法体。
  2.一个接口表示“所有实现了该接口的类看起来都长这样”，所以任何使用特定接口的类都知道可以调用那些方法。因此接口可以看作是建立类与类之间的协议。
  3.接口的创建：
    (1)用interface代替class关键字
    (2)可以在interface前面加上public关键字(仅限该接口在与其同名文件中被定义)。如不添加public则具有默认的包访问权限。
    (3)接口也可以包含域，但是这些域被隐性制定为static和final的。
  4.使用接口，将extends换成implements，并且在接口中不需要使用abstract关键字
  5!.接口拥有和抽象类(基类)一样的多态(向上转型特点)。
  eg：
  interface Instrument{
  	void play();
  }
  class Pianp implements Instrument{
  	public String toString(){return "piano"}
    public void play(System.out.println("piano"));
  }
  ...
  static void tune(Instrument i){  ----  接口的类型被作为参数列表中的成员，说明有着与抽象类一样的作用和多态特点
    i.play();
  }
!?9.3 完全解耦
  1.通过基类的方式写出来的接口有时候耦合过紧(还没太懂耦合是啥意思)，使用接口可以解耦使得各个不同的类都可以使用这一思想。
  2!.适配器设计模式：通过继承接口，为不同的类创建适配器类，以对应不用的类，这样就可以实现，同一个接口却有着对不同类的支持。
  3!.适配器模式主要作用：吧一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法工作的两个类能一起工作(吧适配类的API转换成目标API)
  eg：P177
  eg：A类需要使用B类的.target()函数，但是B只有.func()函数，这时可以用两种方式创建适配器从而将B类中的.func()方法适配为A类可以接受的.target()方法：
  class B{
  	public void func(){}
  }
  (1)类的适配器模式(通过继承)
  a.创建适配器接口target
  public interface Target{
  	public void target();  ----  方法名为B类中没有的接口，并且让B类继承此接口从而实现这个A类需要的接口。
  }
  b.创建适配器类(继承自原来不兼容的B类以及进行类适配的接口)
  public class Adapter extends B implements Target{
  	public target(){
  		this.func();  ----  这样在A需要.target()的时候，可以直接使用Adapter类中的target接口，Adapter继承自B所以可以进行向上转型操作。
  	}
  }
  ~~~~
  Adapter adapter = new Adapter();
  adapter.target();
  (2)对象的适配器模式(通过代理)
  a.创建适配器接口target
  public interface Target{
  	public void target();  ----  方法名为B类中没有的接口，并且让B类继承此接口从而实现这个A类需要的接口。
  }
  b.创建适配器类(将原不兼容的B类作为字段放在适配器类之中)
  public class Adapter implements Target{
  	private B b;
  	public void target(){
  		b.func();  ----  这样调用target时，B中的.func()运行，解决不兼容问题。使用代理进行适配，所以不能进行向上转型操作。
  	}
  }
  (3)类适配器与对象适配器的比较
  a.类适配器：只操作一个对象，代码简化，操作方便，并且不需要额外的字段。
             但是高耦合，灵活性低。
  b.对象的适配器：灵活性高，低耦合。
                 使用复杂，需要引入对象实例。
  4.适配器设计模式的使用场景：
    (1)系统需要复用类，但是该类接口不符合系统需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
    (2)多个组件功能类似，但是接口不统一，需要经常切换时，可以使用适配器模式，使得客户端可以以统一的接口使用他们。
  5.总结：尽量使用对象的适配器模式，少用继承。
!9.4 多重继承
  1.接口没有实现，也代表着没有任何与接口相关的储存。这就无法阻止多个接口的组合。
  2.多重继承需要处理多个类的具体实现，但是在java中可以使用多个接口来使用，因为多个接口只需要关心一个类的具体实现。
  3.如果要从一个非接口的类继承，需要从这一个类继承。其余基类元素都必须是接口。将所有接口名称放在Implement关键字之后，用逗号隔开。
  4.可以继承任意多个接口，也可向上转型为每个接口。以为每一个接口都是一个独立的类型。
9.5 通过继承来扩展接口
  1.可以通过继承在新街口中组合数个接口，从而获得组合在一起的新的接口(继承接口将获得继承的接口的方法，然后再此接口中可以加入新的接口用于扩展，继承多个接口则可以将接口组合在一起)
  eg：
  interface A{
    void a();
  }
  interface AA extends A{
  	void aa();
  }
  interface B{
  	void b();
  }
  interface C extends AA,B{  ----  extends在继承类的时候在后面只能写入一个类(继承类只能继承一个类)，但是接口的继承可以通过extends继承多个接口
  	void c();
  }
  class D implements C{
  	public void a(){}  ----  D类中需要实现所有在C接口结构中的所有方法
  	public void aa(){}
  	public b(){}
  	public c(){}
  }
  9.5.1 组合接口时的名字冲突
    1.在打算组合的不同接口中使用相同的方法名通常会造成代码的可读性的混乱，应该尽量避免这种情况。
9.6 适配接口
  1.接口允许同一个接口具有多个不同的具体实现(体现为不同implements该接口的不同类，在类中的不同实现)。并且方法的参数列表中还可以接受接口类型(接口类型实际上就是implements了该接口的类，比如class A implements Read，则接口Read类型为输入参数的方法中传入A不会报错，其中Read就可以当作是A的基类来看待)。
  2.通过这种情况，可以在任何现有类之上添加新的接口，这样意味着，添加了接口的类，可以作为接口该接口方法的参数输入给该方法，这是一种让任何类都可以对该方法进行适配的方式。
  eg：
  interface Read{
  	void read();
  }
  class A implements Read{
  	public void read(){}
  }
  class implements Read{
  	public void read(){}
  }
  class Test{
  	public static void test(Read read){
  		read.read();
  	}
  }
  ...
  Test.test(A);  
  Test.test(B);  ----  这两句都可以通过编译，因为A,B都是Read类型(继承自Read接口)，通过这种方式可以让任何类通过继承接口而作为输入参数给test()方法，灵活性及其强大。
9.7 接口中的域
  1.接口中的任何域都是static和final的，接口中的域是自动声明为public的。(在enum出现之前，就是用接口来定义enum)
  9.7.1 初始化接口中的域
    1.接口中定义的域不能是空final(在普通的类中可以是空final，可以在对空final进行初始化之后使其保持final特性)，但是可以被非常量表达式初始化。
    eg：
    int RANDOM_INT = RAND.nextInt(10);
!9.8 嵌套接口
  1.接口可以嵌套在类或者其他接口之中。
  2.类中可以嵌套接口的情况：
    (1)类中可以嵌套public接口(如果没有public就是只有包访问权限)：对外可以访问，外部可以通过class.InterfaceName进行访问。
    (2)类中可以嵌套private接口：没有对外的访问权限，只有在本类中才有访问权限(访问权限其实也指实现权限)。这意味着，除了本类，其他类不能对private接口进行实现，也无法对此private接口进行向上转型操作。如果需要使用此接口，只能通过访问包含private接口的对象进行访问(因为包含private接口的类有权限使用这些接口)
    eg：
    class A{
    	public interface B{  ----  可以被外部访问
    		void b();
    	}
    	private interface C{  ----  只能够通过A对象进行访问，也只有A类内部才能对C进行实现
    		void c();
    	}
    	class AA implements C{
    		public void c(){}
    	}
    	public void useC(C c){
    		c.c();
    	}
    	public void getC(){
    		return cc;
    	}
    	private C cc;
    }
    ~~~~
    class D implements A.B{}  ----  通过A.B，在外部对public接口进行实现
    ...
    A a = new A();
    a.useC(a.getC);  ----  只有A对C有使用权限，只能通过这种方式进行访问C
    (3)接口中可以嵌套接口：接口中的域都是默认public的，所以接口中的接口只能是public(没法声明private的接口在接口中)。
    (4)当实现某接口的时候，并不需要实现嵌套在其内部的任何接口。
    eg：
    interface A{
    	interface B{
    		void b();
    	}
    	void a();
    }

    class A implements A{
    	public void a(){}  ---- 没有必要实现嵌套在A中的B接口。(只实现A即可)
    }
    class B implements A.B{
    	public void b();  ----  接口中的接口都是public的，并且可以通过A.B进行访问
    }
!9.9 接口与工厂
  1.工厂模式：生成遵循某个接口的对象的典型方式就是工厂设计方法。
  eg：
  interface Service{  ----  定义一个Service接口作为工厂需要生产的对象的通用类型
  	void method();
  }
  interface ServiceFactory{  ----  定义一个工厂，作为生产某种Service对象的工厂
  	Service getService();
  }
  class Type1 implements Service{  ----  Type1对于Service的实现
  	public void method(){
  		System.out.println("Type1");
  	}
  }
  class Type1Factory implements ServiceFactory{  ----  Type1Factory专门生产Type1类型并且通过Service类型返回
  	public Service getService(){
  		return new Type1();
  	}
  }
  class Type2 implements Service{
  	public void method(){
  		System.out.println("Type2");
  	}
  }
  class Type2Factory implements ServiceFactory{
  	public Service getService(){
  		return new Type2();
  	}
  }
  class Test{
  	public static void useService(ServiceFactory s){
  		Service ser = s.getService();
  		s.method();
  	}
  }
  ....
  Test.useService(new Type1Factory());  ----  输入一个接口类型，通过工厂模式返回一个Service类型的对象并且加以执行对应的方法。
  Test.useService(new Type2Factory());
  输出为：
  Type1
  Type2
9.10 总结
  1.对于创建类，几乎在任何时刻都代替为创建一个接口和一个工厂。但是恰当的原则应该是优先使用类而不是接口。

!第十章 内部类

  1.可以将一个类放在另一个类内部，就是内部类
10.1 创建内部类
  1.创建内部类就是简单的把类的定义置于外围类的里面：
  eg：
  public class P{
  	class Content{
  		private int i = 11;
  		public int value(){return i;}
  	}
  	public void ship(String dest){
  		Content c = new Content();
  	}
  }
  ....
  P p = new P();
  p.ship();
  2.可以使用一个方法返回内部类对象的引用：
  eg：
  public class A{
  	class B{

  	}
  	B to(){
  		return new B();
  	}
  }
  3.如果想从外部的非静态方法之外的任意位置创建某个内部类对象，必须使用OuterClassName.InnerClassName
  eg：
  public class A{
  	class B{

  	}
  	B to(){
  		return new B();
  	}
  }
  ....
  A a = new A();
  A.B b = a.to();
10.2 链接到外部类
  1.内部类可以访问其外围对象的所有成员，不需要任何特殊条件。并且内部类还拥有其外围类的所有元素的访问权。
  2.内部类只能在于其外围类的对象相关联的情况下才能被创建(除了static内部类)
10.3 使用.this和.new
  1.在内部类中的.this使用情况：
    (1)如果只是单单的使用.this：则是指this所在的内部类
    (2)如果是使用了外部类名字+.this，则是指内部类所在的外部类
    eg：
    class A{
    	class B{
    		public A outer(){
    			return A.this;  ----  返回外部类的引用，使用A.this从内部类链接到外部类
    		}
    	}
    }
  2.想要直接创建内部类的对象，必须依靠已经存在的外部类对象(因为内部类的创建依赖于一个对外部类对象的引用)。所以在创建一个内部类之前，必须先实例化一个外部类。
  eg：
  A a = new A();
  A.B b = a.new B();  ----  在类型上要使用A.B，在使用new要使用对象的引用.new来创建内部类实例。
  3.在拥有外部类之前是不可能创建内部类对象的，除非你创建的是嵌套类(static内部类)。
10.4? 内部类与向上转型
  1.当内部类向上转型为基类(接口类型)时，此内部类的实现能够完全不可见，并且不可用。得到的只是指向基类或者接口的引用。
  eg：
  public interface D{
  	void d();
  }
  class A{
  	private class B implements D{
  		public void d(){}
  	}
  	protected class C implements D{
  		public void d(){}
  	}
  	public B getB(){
  		return new B();
  	}
  	public C getC(){
  		return new C();
  	}
  }
  ....
  A a = new A();
  A.B b = a.getB();
  //A.B b = a.new B();  ----  无法通过编译，因为内部类B是private无法直接使用其类，所以虽然其内部类实现了D接口但是对外并不可见
  A.C c = a.getC();
  2?.private内部类给设计者提供了一种途径，通过这种途径可以完全组织任何依赖于类型的编码，并且完全的隐藏了实现细节。
10.5 在方法和作用域内的内部类
  1.可以在一个方法或者一个作用域里面定义一个内部类：
    (1)因为你实现了某类型的接口，于是可以创建并返回对其的引用。
    (2)因为你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是不希望这个类是公共可用的。
  2.局部内部类：在方法作用域内创建的内部类
    eg：
    class A{
    	public B B(){
    		class C implements B{

    		}
    		return new C();  ----  返回类型为B(接口类型)，但是return中的是继承了B的C
    	}
    }
10.6? 匿名内部类
  1.匿名内部类是创建一个继承自相应对象类型(或者接口)内部类对象。
  eg：
  class A{
  	public B B(){
  		return new B(){  ----  从这里开始对匿名类的定义，其实是定义了一个继承自B的对象，然后向上转型，在定义了之后将子类返回给了引用。
  			private int i = 11;
  			public void b();
  		};  ----  分号必须有，因为这本来是一句完整的创建对象的语句，所以必须有分号
  	}
  }
  2.如果匿名类的基类需要有参构造器：
  eg：
  class A{
  	public B B(){
  		return new B(x){  ----  平常创建对象怎么输入的参数，在这里就怎么输入，这里调用的是基类的有参构造器
  			//...	
  		}
  	}
  }
  3.匿名类没有命名构造器(因为没有名字啊！)，所以如果在匿名类中进行初始化，则只能使用实例初始化。
  4?.在匿名类中想要对基类中的字段进行赋值，则编译器要求参数引用必须是final的。
  eg：
  class A{
    public B B(final String str,final int num){  ----  这里的参数是为了在内部类中进行初始化用的。
    	return new B(){
    		private int i = 11;
    		{  
    			cost = str;  ----  这里的定义在{}之中，因为if语句不能单纯的出现在字段之中。这里的效果与调用构造器一致，但是不能使用重载构造器。
    			if(num>100) number = num;
    			else number = 0;
    		}
    		public void b();
    	};
    }
  }
  10.6.1 再访工厂方法
    1.使用匿名类可以简化工厂模式的代码结构，可以将Factory类以静态的方式在Service的定义中实现：
    eg：
    ...
    public Type1 implements Service{
    	public void method();
    	public static Type1Factory = new Type1Factory(){
    		public Service getService(){
    			return new Type1();
    		}
    	};
    }
10.7 嵌套类
  1.嵌套类不需要内部类对象与其外围对象之间有联系，那么可以将内部类声明为static。
    (1)要创建嵌套类的对象，并不需要其外围类对象
    (2)不能从嵌套类的对象中访问非静态的外围类对象
  2.普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和字段，也不能包含嵌套类。但是嵌套类可以包含这些东西。
  10.7.1 接口内部的类
    1.接口内部都是默认public和static的，所以接口内部的类都是static和public的类。甚至可以在内部类实现其外围接口。
    eg：
    public interface A{
    	void a();
    	class Test implements A{
    		public void a(){}  ----  可以在接口内部对外部接口进行实现。
    	}
    }
    2.接口内的嵌套类可以用作公共代码，使得他们可以被某个接口的所有不同实现所公用。
  10.7.2 从多层嵌套类中访问外部类的成员
    1.一个内部类被嵌套多少层并不重要，它能透明的访问所有它嵌入的外围类的所有成员。
!10.8 为什么需要内部类
  1.内部类可以享用到接口带来的方便，有时候需要用到接口的实现。
  2.每一个内部类都能独立的继承自一个接口的实现，所以无论外围是否已经继承了某个实现，对于内部类都没有影响。
  3.内部类有效的实现了多重继承(外部类继承自抽象类，内部类可以继承自接口，从而在结构上实现真正的多重继承而没有影响。
  eg：
  当需要在一个类中以某种方式实现两个接口，有两个方案：
    (1)单一类继承自两个接口
    (2)外部类继承一个接口，另一个继承另一个接口(一个是抽象类，一个是接口)
  4.使用内部类还可以获得其他的特性：
    (1)内部类可以有多个实例，每一个实例都有自己的状态信息，并且与外围类对象的信息相互独立。
    (2)在单个外围类中，可以让多个内部类以不同方式实现同一个接口，或者继承同一个类。
    (3)?创建内部类对象的时刻并不依赖于外围类对象的创建
    (4)内部类没有is-a关系，就是一个独立的实体。
  10.8.1 闭包与回调
    1.内部类是面向对象的闭包
  !10.8.2 内部类与控制框架
    P208
10.9 内部类的继承
  1.内部类的构造器必须连接到只想其外围类对象的引用。
  eg：
  class A{
  	class B{

   	}
  }
  ~~~~
  class C extends A.B{
  	C(A a){  ----  继承自内部类需要输入外部类的引用
  		a.super();
  	}
  }
  ....
  A a = new A();
  C c = new C(a);  ----  创建继承自内部类的类时候，也需要先实例化一个外部类的对象
10.10 内部类可以被覆盖吗
  1.覆盖内部类时候(继承自外部类，然后重新定义次内部类)，内部类并没有特别的变化，这两个内部类是完全独立的两个实体，都在自己各自的命名空间内。
  2.内部类可以明确的继承内部类：class Inner extends Outer.AnotherInnerClass{}，这时的内部类会正确进行覆盖。
10.11 局部内部类
  1.局部内部类是在一个方法里面创建类，所以局部内部类没有访问说明符。虽然不能访问外部内的域，但是可以当问当前代码块内的常量以及此外围类的所有成员。

第十一章 持有对象

  1.基本的类型的容器库是List，Set，Queue，Map。
11.1 泛型和类型安全的容器
  1.ArrayList可以当作一个可以自动扩充自身尺寸的数组。
    (1)可以使用@SuppressWarning来抑制异常的抛出。
    (2)ArrayList使用.add()添加对象，使用.get()取出对象。.size()返回List的尺寸。
    (3)如果不用泛型就添加对象，取出的对象都是Object对象的，需要在前面加上括号进行强制转型为自己需要的类型。
    (4)使用泛型：ArrayList<String> list = new ArrayList<String>();使用尖括号表示List可以接受的类型。(使用泛型，当你放入错误的类型的时候，在编译期间就会得到错误，并不是在运行之后)。并且在取出对象时也不需要强制转型。
    (5)可以使用foreach进行遍历操作：for(String str:list){//body...}
    (6)向上转型一样可以作用于泛型，因此可以将String的子类添加到list容器中。
11.2 基本概念
  1.JAVA容器类类库的用途是保存对象，并将其划分为两种概念：
    (1)Collection：一个独立元素的序列，并且这些元素都服从一条或者多条规则。
      a.List必须按照插入顺序保存元素
      b.Set不能有重复元素
      c.Queue按照排队规则来确定对象产生的顺序(与他们被插入的顺序相同)
    (2)Map：一组成对的键值对对象，允许你使用键来查找值。
      a.ArrayList可以使用数字与对象相关联。
      b.映射表允许使用另一个对象来查找某个对象，也成为字典
  2.可以使用接口类型创建容器类实例：
  eg：List<Apple> list = new ArrayList<Apple>();  ----  ArrayList向上转型为List(但是只能使用List的接口)
  这种方式不是总是奏效的比如LinkedList也是List的子类，但是LinkedList有着额外的方法，使用List进行声明的话，不能使用这些额外的方法。TreeMap同样也有额外的方法。所以使用这样的容器类的时候不能进行向上转型。
  3.Collection：
  eg：
  Collection<Integer> collection =  new ArrayList<>();
  for(int i=0;i<10;i++){
  	collection.add(i);
  }
  for(Integer i:collection){
  	//...
  }  ----  所有Collection的子类都可以这样使用，但是因为Set也是Collection的子类，所以在.add()时需要注意是否已经存在要添加的对象。
11.3 添加一组元素
  1.Array.asList()：返回List对象
    (1)接受一个数组。
    (2)接受可变参数列表：new ArrayList<Integer>(Arrays.asList(1,2,3,4,5));
    (3)??在使用List作为容器类的时候，List不支持.add()和.remove()等改变改变尺寸的方法。因为List底层是数组，所以不能修改尺寸。
  2.Collections.addAll()：返回Collection对象，注意Collection后面有没有s
    (1)接受一个Collection对象。
    (2)接受一个数组。
    (3)接受一个可变参数列表。
    (4)Collection.addAll()只接受一个Collection对象，不如前两者灵活。(末尾没有s)
  3.Array.asList()可能会引发向上转型的问题：
  eg：
  class Snow{}
  class Powder extends Snow{}
  class Light extends Powder{}
  ...
  List<Snow> snow1 = Array.asList(new Powder(),new Light());  ----  不会报错，因为Powder继承自Snow
  //List<Snow> snow2 = Array.asList(new Light());  ----  报错，只有Powder,所以只会返回List<Powder>
  List<Snow> snow3 = new ArrayList<>();
  Collections.addAll(snow3,new Powder());  ----  Collections.addAll()不会报错，因为已经从snow3得知了需要的类型。
11.4 容器的打印
  1.容器类可以很好的使用自身的toString()方法与System.out.println()进行协作。(就直接Sop(一个容器)就行)
  2.继承结构：
    (1)Collection:每个槽中只能保存一个元素
      A.List:按照被插入的顺序保存元素
        a.ArrayList:与LinkedList的操作耗时不同，擅长于随机访问元素，但是插入移除元素时较慢。
        b.LinkedList:与ArrayList的操作耗时不同，随机访问较慢，擅长顺序访问和插入删除。
      B.Set:每一个相同项只保存一次;
        a.HashSet:最快的获取元素的方式。
        b.TreeSet:按照比较的结果的升序保存对象(当你需要使用一个储存顺序很重要的Set的时候使用)
        c.LinkedHashSet:按照被添加的顺序保存对象，并且保持最快的获取元素。
    (2)Map:使用键来查找值，即每一个槽保存两个元素。Map.put(key,value);Map.get(key);用来存储提取键值。
      A.HashMap:最快查找速度的Map
      B.TreeMap:按照比较升序保存键
      C.LinkedHashMap:按照插入顺序保存键，同时保持了最快查找速度。
!11.5 List
  1!.ArrayList<>常用API：
    (1)void .add(<Object> o)：在ArrayList的末尾位置添加一个泛型的对象，ArrayList的size也会变化。
    (2)void .add(int index,<Object> o)：在index得序号处插入一个对象o，后面的对象向后移动。
    (3)void .addAll(int index,List<> otherList)：在原list的index插入整个otherList，后面的元素向后移动。
    (4)boolean .contains(<Object> o)：判断ArrayList中是否已经含有对象o，如果有返回true，否则返回false(会用到对象的.equals()方法进行比较，所以涉及到.equals()重载的具体实现机制)。
    (5)void .remove(<Object> o)：从ArrayList中移除一个对象o，会通过.equals()进行比较，涉及到.equals()重载的具体实现。
    (6)void .remove(int index)：按照index移除元素。
    (7)void .removeAll(List<> subList)：在原list中一处subList中一样的的元素。(依赖.equals())
    (8)<Object> .get(int index)：从List中获取一个泛型的对象，输入List中的序号(int)
    (9)int .indexOf(<Object> o)：查询对象o对List中的序号。
    (10)List<> .subList(int index1,int index2)：将index1到index2处的List截取出来为另一个List，并返回。其中包括[index1,index2)。
    (11)boolean .containsAll(List<> subList)：原List中是否包含子List-subList，如果包含则返回true，否则返回false。是否包含于顺序无关。
    (12)void Collections.sort(List<> list)：将list中的元素进行排序。
    (13)void Collections.shuffle(List<> list,Random rand)：将list中的元素按照rand随机数进行随机打乱顺序。
    (14)void .retainAll(List<> subList)：将原list只保留与subList相交的元素，其余元素全部删除，该效果直接作用于原list，所以没有返回值。(以来.equals())
    (15)void .set(int index,<> o)：将序号为index的元素更新为对象o。
    (16)boolean .isEmpty()：判断list是否为空，如果为空则返回true，反之返回false。
    (17)void .clear()：清空整个list。
    (18)<>[] .toArray(<>[])：将list转变为制定类型的数组(无参版本则返回Object[])。
    eg：
    Pet[] pa = pets.toArray(new Pet[0]);  ----  ？为啥是0？
  2.ArrayList的copy方式：
    List<Pet> copy = new ArrayList<>(pets);
!11.6 迭代器
  1.迭代器(设计模式)：是一个轻量级对象，用于遍历并选择序列中的对象。(可以用来将一份代码用在多种容器类中，例如Set没有ArrayList中的API)
  2.由于迭代器是一个轻量级对象，所以只能用来做一些特定的操作(只能向前移动)。
  3.Iterator的API：
    (1)Iterator list<>.iterator()：返回特定容器的一个迭代器，并且迭代器将准备好返回第一个元素(意思是第一次调用.next()将返回第一个元素)。
    (2)<> .next()：返回该容器的下一个对象。
    (3)boolean .hasNext()：检查序列中是否还有下一个元素。
    (4)void .remove()：将刚刚用next返回的元素在list中删除(所以调用remove之前必须先调用.next()并且用.next()将迭代器移动到你想要的位置，再进行删除)。
  11.6.1 ListIterator
    1.专门用于List的迭代器，可以在制定位置创建，并且可以向前向后移动，而且还有当前元素的前一个元素和后一个元素的索引。
    2.ListIterator的API：
      (1)迭代器的创建：
      eg：
      ListIterator listIterator = pets.listIterator();  ----  创建一个指向开头的迭代器
      ListIterator listIterator = pets.listIterator(3);  ----  创建一个指向第三个元素的迭代器
      (2)判断前后是否有元素：
      eg：
      listIterator.hasNext();  ----  如果有true，反之false
      listIterator.hasPrevious();  ----  如果有true，反之false
      (3)获取元素：
      eg：
      listIterator.next();  ----  返回下一个元素
      listIterator.previous();  ----  返回上一个元素
      listIterator.nextIndex();  ----  返回下一个元素的索引(序号)
      listIterator.previousIndex();  ----  返回上一个元素的索引(序号)
      (4)更新元素：
      listIterator.next();
      listIterator.set(new Pet());  ----  将next()当前返回的元素更新。
11.7 LinkedList
  1.在随机访问的时候速度不如ArrayList，但是插入和删除速度更快。
  2.LinkedList还添加了作为栈，队列，双端队列的方法。
  3.LinkedList对于stact,queue,和双端队列的API会在后面给出。
  4.LinkedList的API：
    (1).getFirst(),.element()完全一样，都返回list列表的第一个元素，但是并不移除这个元素。若list为空则抛出NoSuchElementException异常。
    (2).peek()同样返回列表的第一个元素，而且不移除，但是如果列表为空则返回null
    (3).remove()--(没有参数)，和removeFirst()是完全一样的，移除第一个元素，同时返回该元素。如果列表为空则抛出NoSuchElementException异常。
    (4).poll()，返回并且移除第一个元素。如果列表为空则返回null。
    (5).addFirst(<>)，将元素加入到列表的头部。
    (6),.add(<>),addLast(<>)，将元素添加到元素的尾部。
    (7).removeLast()，移除最后一个元素(尾部)。
11.8 Stack
  1.先进后出(LIFO),最后压入栈的元素第一个被压出。
  2.LinkedList具有能够实现栈的所有方法。
  3.Stack的基于LinkedList的泛型实现：
  eg：
  public class Stack<T>{
  	private LinkedList<T> storage = new LinkedList<>();
  	public void push(T v){
  		storage.addFirst(v);
  	}
  	public void pop(T v){
  		return storage.removeFirst();
  	}
  	public T peek(){
  		return storage.getFirst();
  	}
  	public boolean isEmpty(){
  		return storage.isEmpty();
  	}
  	public String toString(){
  		return storage.toString();
  	}
  }
  4.栈经常在编程语言中队表达式进行求值。
11.9 Set
  1.Set不保存重复的元素，Set会阻止你将相同元素添加到Set中。
  2.Set不具有多余的接口，Set实际上就是Collection对象，只是表现不同。
  3.HashSet，使用散列技术。TreeSet将元素储存在红黑树中。如果想对接口进行排序，可以使用TreeSet。
11.10 Map
  1.将对象映射到其他对象。
  2.eg：
  ....
  .put(key, value==null?1:value+1);  ----  如果key对应的value没有值，则从1开始计算，如果有则值加一(不需要使用if)。(太牛逼了)
  3。.getKey(<> o),取出key对象为o的value。
  4。.getValue(<> o),去除value值为o的key对象。
  5.Map的Value或者Key对象同样可以声明为其他容器类(可以在Map中嵌套其他List甚至其他Map).
  6。.keySet()，返回一个由这个Map的所有键组成的Set。可以使用foreach语法对这个Set进行遍历从而对Map进行遍历
  7。.values()，返回一个由这个Map的组所value组成的Collection对象。
  8。.entrySet()，返回一个由Map的key和value一起组成的实体对象。
  eg：
  Set entries = map.entrySet();  ----  获取<key,value>一起组成的尸体对象
  if(entries != null) {
  	Iterator iterator = entries.iterator();  ----  遍历entries也要使用迭代器
  	while(iterator.hasNext()) {
  		Map.Entry entry =iterator.next();
  		Object key = entry.getKey();  ----  通过每一个entry来获取key和value值。
  		Object value = entry.getValue();
  	}
  }
11.11 Queue
  1.队列是一个先进先出的容器。从一端放入事物从另一端取出。
  2.LinkedList实现了Queue的接口，需要将LinkedList进行向上转型。(需要这样创建Queue：Queue<Integer> queue = new LinkedList<>();)
  3.Queue的API：
    (1).offer(<> o)，将一个元素插入到队尾。
    (2)peek(),element()，都在不移除的情况下返回队列最开始的元素(队头)。若队列为空，peek()返回null，而element()则返回NoSuchElementException。
    (3)poll(),remove()将移除并且返回队头。当队列为空时，poll()返回null，remove()则抛出NoSuchElementException异常。
    11.11.1 PriorityQueue
      1.优先级队列，队列中弹出的是优先级最高的元素。当元素被.offer()的时候会自动在队列中被排序。
      2.PriorityQueue可以保证当你调用peek()，poll(),remove()的时候能够得到优先级级最高的元素。
      3.可以通过Comparator对优先级队列的排序规则进行改写，17章中将详细讲。
11.12 Collection和Iterator
  1.虽然看起来Collection是容器类之间的共性，但是使用Iterator能够更好的表达容器类之间的共性
  2.用Collection接口实现与底层容器的特定实现解耦：
  eg：
  public static void display(Collection<Pet> pets){
  	for(Pet p:pets){
  		System.out.println(p);  ----  通过在参数里面输入Collection，可以使任何容器类都能够调用display()方法。
  	}
  }
  3.用Iterator接口实现与底层容器的特性实现的解耦：
  eg：
  public static void display(Iterator<Pet> it){
  	while(it.hasNext()){
  		Pet pet = it.next();
  		System.out.println(pet);  ----  通过Iterator接口进行解耦。
  	}
  }
11.13 Foreach与迭代器
  1.Collection类型可以直接用foreach进行遍历，因为foreach语法内部使用了Collection的迭代器对序列进行了遍历操作，所以任何一个类只要手动实现了Iterable<>接口都可以使用foreach直接遍历。
  eg：
  public class IterableClass implemnts Iterable<String>{
  	private String[] words = {"a","b","c"};
  	public Iterator<String> iterator(){
  		return new Iterator<String>{  ----  使用匿名内部类返回一个自己实现的Iterator方法，从而外部在对次对象进行foreach时，foreach可以在内部对其进行相应的迭代器操作
  			private int index = 0;
  			public boolean hasNext(){
  				return index < words.length;
  			}
  			public String next(){
  				return words[index++];
  			}
  			public void remove(){  ----  这句不会被执行
  				throw new UnsupportedOperationException();
  			}
  		}
  	}
  }
  ....
  for(String s:new IterableClass()){  ----  由于实现了迭代器接口，所以IterableClass对象可以使用foreach语法
  	System.out.println(s);
  }
  2.可以使用foreach的是所有的数组和Iterable，但是不意味着数组也是一个Iterable，而且自动包装也不会发生。所以当尝试将一个数组当作一个Iterable参数的时候，会传入失败。
  11.13.1 适配器方法惯用法
    1.当需要foreach的语法中产生不同的遍历操作(比如正向遍历，或者反向遍历)，需要使用适配器方法。
    eg：
    class ReversibleArrayList<T> extends ArrayList<T>{
    	public ReversibleArrayList(Collection<T> c){ super(c); }
    	public Iterable<T> reversed(){  ----  返回Iterable<t>接口类型
    		return new Iterable<T>(){  ----  返回一个接口类型，并且进行定义。
    			public Iterator<T> iterator(){  ----  在返回的接口类型中再重新实现迭代器的具体实现(与直接重新实现迭代器多了一层返回接口类型)
    				int current = size()-1;
    				public boolean hasNext(){ return current > -1; }
    				public T next() { return get(current--); }
    				public void remove(){
    					throw new UnsupportedOperationException();
    				}
    			}
    		};
    	}
    }
    ....
    ReversibleArrayList<String> ral = new ReversibleArrayList<String>(Array.asList("a","b","c"));
    for(String s:ral){
    	//...  ----  这里是正向迭代器，会进行向上转型，将ReversibleArrayList向上转型为ArrayList然后使用ArrayList的迭代器
    }
    for(String s:ral.reverse()){
    	//...  ----  这就是返回接口类型的原因，这里返回了具有相反实现的Iterable<>的对象，所以在foreach中会自动调用这个Iterable<>的迭代器--在接口的匿名类下面实现的迭代器定义，就是相反操作的迭代器。
    }
11.14 总结
  1.数组：将数字与对象结合起来。可以是多维的。但是不能改变容量。
  2.Collection：保存单一的元素
  3.Map：将对象与对象结合起来(而不是简单的数组索引)。
  4.List也是建立数字与对象的关联(与数组一样)。
  5.需要大量的随机访问，使用ArrayList。需要大量的插入删除操作，使用Linkedlist。

第十二章 通过异常处理错误

12.1 概念
12.2 基本异常
  1.异常情形：是指阻止当前方法或作用域继续执行的问题。(普通的问题是指，在当前环境下能得到足够的信息，总能处理这个错误。而异常不可以，异常需要跳出将问题提交给上一级环境)
  2.当一个异常被抛出之后：
    (1)将使用new在堆上创建异常对象。
    (2)然后，当前执行路径(不能继续执行了)被终止，并且从当前环境中弹出对异常对象的引用。
    (3)异常机制接管程序，并寻找一个恰当的地方来继续执行程序。恰当的地方就是异常处理程序。
    (4)异常处理程序将程序从错误状态中恢复，要么换一种方式运行，要么继续运行下去。
    eg：
    if(t == null){
    	throw new NullPointerException();
    }
  12.2.1 异常参数
    1.异常对象的创建：(异常对象和其他对象一样，都使用new在堆上创建对象)
      (1)一种是默认构造器
      (2)另一种是接受一个字符串作为参数，以便能把相关信息放入异常对象的构造器中。
      eg：throw new NullPointerException("t=null")；
    2.能够抛出任意类型的Throwable对象，因为它是异常类型的根类。
12.3 捕获异常
  12.3.1 try代码块
    1.try代码块(监控区域)：在某方法出现了异常，若是不希望方法就此结束，可以在方法内设置一个特殊的try快来捕获异常(在这个块中进行各种方法调用的尝试)。它是一个跟在try后面的普通代码块
    try{
    	//...	----  可能出现异常的代码
    }
  12.3.2 异常处理程序
    1.catch：针对每个要捕获的异常，得准备相应的处理程序。异常处理程序紧跟在try之后，以关键字catch表示：
    try{
    	//...  ----  可能出现异常的代码
    }catch(Type1 id1){
    	//...  ----  针对Type1类型异常的异常处理程序
    }catch(Type2 id2){
    	//...
    }...
    2.异常处理程序必须紧跟在try块之后。当异常被抛出之后，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入catch子句，一旦catch字句运行结束，则处理程序的查找过程结束。
    3.在try得内部如果许多不同的地方调用可能会产生相同类型的异常，但是你只需要提供一个针对此类型的异常处理程序。
    4.终止模型与恢复模型：
      (1)终止模型：将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已经无法挽回，也就不能继续执行。
      (2)恢复模型：意思是异常处理程序的工作是修复错误，然后重新尝试调用出问题的方法，并认为第二次能成功。如果想在java中实现恢复模型，则不能抛出异常，而是需要调用方法来修正错误，或者把try放在while内。
    5.更倾向于使用终止模型，因为恢复模型的耦合性太强，需要了解异常抛出的地点需要依赖于抛出位置的非通用性代码。增加了维护和编写的困难。
12.4 创建自定义异常
  1.自己定义异常类，必须从已经有的异常类继承，最好选择意思相近的异常类继承。
  eg：
  class SimpleException extends Exception{}  ----  将自己的异常继承自另一个异常
  public class InheritingException{  ----  一个可以生成异常的对象
  	public void f() throws SimpleException{  ----  次方法可以生成异常
  		System.out.println("SimpleException from f()");
  	}
  	public static void main(String[] args){
  		InheritingException sed = new InheritingException();
  		try{
  			sed.f();
  		}catch(SimpleException e){
  			System.out.println("catch it");  ----  成功抓获异常
  		}
  	}
  }
  2.也可以在定义异常类的时候，接受一个字符串参数。
  eg：
  class MyException extends Exception{
  	public MyException() {}
  	public MyException(String msg) { super(msg); }  ----  在构造函数接受一个字符串参数的时候，调用基类的构造函数即可。
  }
  3.可以将catch中捕获的异常送到标准错误流中(System.out有事会被重定向，所以System.err更好一点)
  eg：
  try{
  	f();  ----  此方法可以抛出异常
  }catch(MyException e){
  	e.pringStackTrace();
  }
  12.4.1 异常与记录日志
    P253
    1.还可以进一步的自定义异常，让异常包括字段和方法。也可以重载getMessage()方法。(getMessage方法类似于toString)
12.5 异常说明
  1.将会产生异常的方法用特定的方式进行声明，这样使用此方法的程序员会知道用什么方法捕获该异常。(继承自RunTime的异常可以不用在方法中声明就抛出)可能抛出异常的方法都会被编译器强制使用try,catch语句
  eg：
  void f() throws SimpleException,OtherException{  ----  将可能出现的异常写在函数定义的后面
  	//...
  }
  2.发放后面声明的异常必须与方法中抛出的异常一致，如果有异常在方法中被抛出但是没有声明，要么解决这个异常(用try-catch)，要么在方法后面声明此异常。
  3.可以在方法不抛出异常的时候，声明此方法有异常，编译器通过，可以用于在抽象类和接口中为方法中还未涉及到的异常进行占位使用。
12.6 捕获所有异常
  1.可以通过捕获所有异常的基类Exception来捕获代码中出现的任何类型的异常。(但是Exception并不是异常的唯一基类，只是有关编程方面的基类)
  eg：
  catch(Exception e){
  	//...
  }
  2.在使用Exception捕获异常时，尽量将Exception放在很多catch的最后，因为这样可以先处理更加明确的异常。
  3.因为Exception不会包含太多信息，但是可以调用它从Throwable继承的方法来获取详细信息。
  eg：
  String getMessage()
  String getLocalizedMessage()  ----  这两个方法用来获取详细信息，或者使用本地语言表示的详细信息
  String toString()  ----  返回对Throwable的简单描述，如有详细信息也会包含在内
  void printStackTrace()  ----  打印Throwable和Throwbale的调用栈轨迹(输出到标准错误)
  void printStackTrace(PrintStream)  ----  作用同上，但是可以选择输出流
  void printStackTrace(java.io.PrintWrite)  ----  作用同上，可以选择输出流
  Throwable fillInStackTrace()  ----  用于Throwable对象的内部记录栈帧的当前状态。这在程序重新抛出错误或者异常很有用
  .getClass().getName() or .getClass().getSimpleName()  ----  调用继承自Object的方法返回类的完整名(前一个)或者简单的类名
  12.6.1 栈轨迹
    1.可以通过异常的.getStackTrace()方法来访问栈轨迹，这个方法返回一个数组。数组的0元素是本程序抛出异常之前调用的最后一个方法(就是抛出异常的位置)，最后一个元素就是第一个方法。
    eg：
    ...
    catch(Exception e){
    	for(StackTraceElement ste:e.getStackTrace()){
    		System.out.println(ste.getMethodName());  ----  这里只返回了方法名，可以返回的信息还有很多
    	}
    }
  12.6.2 重新抛出异常
    1.可以在catch中重新抛出异常(抛出的异常会上交到上一级，也就是说同一级的try-catch对于catch中新抛出的异常不会处理)，可以使用e.fillInStackTrace()将出现的异常的位置重置在此异常。
    eg：
    catch(Exception e){
    	//...
    	throw (Exception)e.fillInStackTrace();  ----  如果不添加这一句，在使用printStackTrace()时会追踪这一句之前的try之中的具体方法，但是加了这一句，异常的起始位置会重置在这里
    }
  12.6.3 异常链
    1.三种异常可以传入一个Throwable对象在它们的构造器中作为异常链，传入的异常则表示在捕获该异常之后又捕获了异常。这三个异常时：Error，Exception，RuntimeException
    2.其他异常可以用过调用方法.initCause(Throwable e)来对不同的异常添加异常链。
12.7 Java标准异常
  1.Throwbale表达任何可以作为异常被抛出的类。Throwable对象可以分为两类，一种是Error(表示编译时和系统错误，一般不用关心)，另一种就是Exception(指就可以被抛出的异常)。一般关心后者。
  12.7.1 特例：RuntimeException
    1.RuntimeException：运行时异常，这种异常，或者它的子类异常会自动被Java虚拟机抛出，所以不必再异常说明中把他们列出来。属于不受检查异常。(但是同样可以抛出运行时异常)。
    2.RuntimeException代表的是：
      (1)无法预料的错误。比如传递了null引用
      (2)应该在代码中进行检查的错误。
12.8 使用finally进行清理
  1.finally：对于希望无论try中的异常是否被抛出都想要执行的代码，可以放在finally中。一般用于清理内存回收之外的情况。
  2.完整的异常处理程序结构：
  eg：
  try{
  
  }catch(A a1){
  
  }catch(B B1){

  }finally{

  }
  12.8.1 finally用来做什么
    1.finally：用来吧除内存之外的资源恢复到他们初始的状态，包括：已经打开的文件或者网络连接，在屏幕上画的图形，或者某外部世界的某个开关。
    2.在catch中如果重新抛出了异常，则在此异常上交到上一级之前，也会执行着一级的finally语句。
  12.8.2 在return中使用finally
    1.根据finally的特性，可以在有着多个返回点的方法中使用finally保证方法的正常清理工作。
    eg：
    void f(int i){
    	try{
    		if(i==1) return;
    		if(i==2) return;
    		if(i==3) return;
    	}finally{
    		//...  ----  可以在这里进行清理工作，不管从那个return返回这一句都会得到执行。
    	}
    }
  12.8.3 缺憾：异常丢失
    1.异常可能因为finally的不良使用而缺失：
      (1)eg:
      try{
      	lm.f();  ----  会抛出异常1
      }
      finally{
      	lm.g();  ----  会抛出异常2
      }catch(Exception e){
      	System.out.println(e);  ----  只会捕获到异常2(异常1消失了)
      }
      (2)eg：
      void f(){
      	try{
      		lm.f(); ----  抛出异常1
      	}finally{
      		//...
      		return;  ----  因为return在finally内部，所以即使抛出异常也不会产生任何输出。
      	}
      }
12.9 异常的限制
  1.覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常。
  2.虽然异常说明是编译器强制要求的，但是并不属于方法类型的一部分(不能通过异常说明区分重载)
12.10 构造器
  1.如果在构造器中抛出异常，并且类中还有对应的清理用函数时需要格外注意(有些对象需要手动.dispose()进行清理，但是构造器如果出现异常，则不需要清理，则也不需要调用dispose())。可以使用以下结构：
  eg：
  try{
  	InputFile in = new InputFile("name.java")；  ----  会产生异常的构造器的创建与其他成功创建之后的操作分离，这样如果构造器出现异常最外层catch直接捕获，不会运行中间的操作，也就不会调用dispose()
  	try{  ----  表示对象已经成功创建，dispose()中需要清理的也成功创建，所以在这个try-catch中，finally中的dispose是可以正常清理的。
  		//io operation
  	}catch(Exception e){
  		e.printStackTrace();
  	}finally{
  		in.dispose();
  	}
  }catch(Exception e){
  	e.printStackTrace();
  }
12.11 异常匹配
  1.在catch(Type1 e)中，会捕获Type1类异常以及所有Type1的派生类异常。(例如Exception可以捕获几乎所有的异常)
12.12 其他可选方式
  1.异常吞食：
  try{
  	//...
  }catch(Exception e){}  ----  这里才catch之后什么都不做，异常被吞食了，应该避免这样使用。甚至只打印一场的栈轨迹也可以。
  2.把异常传给控制台：在main函数后面throw Exception，在再main函数中打印异常。(不是通用的办法)
  3.可以将异常包装为运行时异常：
  eg：
  catch(Exception e){
  	throw new RuntimeException(e);
  }
12.13 异常使用指南
  1.应该在下列情况下使用异常：
    (1)在恰当的级别处理问题。(就是知道了如何处理的时候)
    (2)解决问题并且重新调用产生异常的方法
    (3)进行少许修补发，然后绕过异常发生地方继续执行
    (4)用别的数据进行计算，以代替方法预计会返回的值
    (5)吧当前运行环境下能做的事情尽量做完，然后把相同的异常重新抛到最高层。
    (6)吧当前运行环境下能做的事情尽量做完，然后把不同的异常抛到最高层。
    (7)终止程序
    (8)进行简化
    (9)让类库和程序更安全

第十三中 字符串

13.1 不可变的String
  1.String对象是不可变的，String类中每一个看起来会修改String值得方法其实都是创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。
  2.String不修改自己对象的值是安全的。
!13.2 重载“+”与StringBuilder
  1.String的+与+=是java中唯一重载的两个操作符。剩下的操作符没有也不允许进行重载。
  2!.String使用+和+=在编译过程实际上是使用了StringBuilder的.append()对操作符进行拼接。
  eg：
  String = "a"+"b"+"c";  ----  实际上创建了多个StringBuilder对象并且进行拼接，不如直接使用一个StringBuilder进行手动拼接性能好。
  3!.在创建(拼接)字符串的时候，尽量使用StringBuilder而不是使用+/+=(在不追求性能以及拼接的字符串不多的时候，可以使用重载之后的操作符)
  4.StringBuilder的API：
    (1).insert()
    (2).replace()
    (3).substring()
    (4).reverse()
    (5).append()
    (6)toString()
    eg：
    StringBuilder str = new StringBuilder("abc");
    str.append("abc");
    String str1 = str.toString();
  5.如果字符串操作需要递归的进行拼接，可以在循环外创建一个StringBuilder然后再循环体内进行.append()操作。
  6.不要写出像：str.append("ab"+"c");的代码，因为括号内部使用了操作符重载了，失去了外部使用StringBuilder的意义。
13.3 无意识的递归
  1.不应该在类的重载方法.toString()中使用重载操作符与this连接。
  eg：
  public String toSring(){
  	return "abc"+this;  ----  本意实在这里使用this打印对象的内存地址，但是因为使用了重载操作符，this(本类)被强制转型为String，于是调用本类的toString()所以会产生无限递归。
  }
!!13.4 String上的操作
  P288
13.5 格式化输出
  13.5.1 printf()
    1.eg:
    printf("Row 1:[%d %f]",x,y);  ----  x将插入到%d的位置，y将插入到%f的位置。%d代表整数，%f代表浮点数。
  13.5.2 System.out.format()
    1.System.out.format()方法模仿自printf()--两者用法一样。
  13.5.3 Formatter
    1.所有格式化功能都有java.util.Formatter处理。
    2.部分API-P290
    3.Formatter类型转换符
    d 	整数型(10进制)
    c 	Unicode字符
    b 	Boolean字符
    s 	String
    f 	浮点数(10进制)
    e 	浮点数(科学计数)
    x 	整数(16进制)
    h 	散列码(16进制)
    % 	字符"%"
  13.5.4 格式化说明符
  	1.语法：
  	eg：
  	%[arguement_index$][flags][width][.precision]conversion
  	百分号后面加“-”表示左对齐，不加则是右对齐。
  	width：表示长度，在长度不足的时候添加空格
  	precision：用来表示精确度。String的precision表示打印的输出字符的最大数量，用于浮点数表示小数部分要显示出来几位。
  	eg：
  	Formatter f = new Formatter(System.out);
  	f.format("%-15s %5s %10s\n","Item","Qty","Price");
  	输出(这是一个发票的发票头)：
  	Item          Qty     Price
  13.5.6 String.format()
    1.String.format()是一个static方法，接受和.format()方法一样的参数，但是返回的是一个String对象。
13.6 正则表达式(略过)
  (略过)P295
  13.6.5 split()
  1.split()方法输入字符串断开成字符串对象数组，断开边界由正则表达式确定。
  String[] split(CharSequence input)
  String[] split(CharSequence input,int limit)  ----  limit是指将字符串分割成size为limit的数组，如果有多处需要分隔，则在达到数组最大size之后不再进行分割
13.7 扫描输入
  1.一般的从文件或者标准输入读取数据就是读入一行，然后进行分词。然后使用Integer,Double等各类解析方法来解析数据。
    (1)StringReader，BufferReader(第十八章)
    (2)Scanner类
  2.Scanner
  eg：
  String input = "abcd jhgyu iuhuiuh oihjoi";
  Scanner scanner = new Scanner(input);  ----  自动将String以空格分隔开。
  while(scanner.hasNext()){
  	System.out.println(scanner.next());
  }

第十四章 类型信息RTTI(Java从入门到放弃的起始章)

14.1 为什么需要RTTI
  1.面向对象的编程目的就是让代码只操纵对基类的引用。由于动态绑定，在调用基类引用的方法时候会正确的使用子类的方法。因此通常会创建一个具体的对象，再把它向上转型为基类类型，并在后面的程序中使用匿名的基类引用。
  2.RTTI：在运行时，识别一个对象的类型。
  3.RTTI可以查询某个基类引用所指向的对象的确切类型，然后选择或者剔除特例。
14.2 class对象
  1.RTTI的工作是由称为class的特殊对象完成的(这个对象包含了与类有关的信息)。即使你正在执行类似转型这样的操作，java还是使用Class对象来执行其RTTI。
  2.每个类都有一个Class对象，每当编写并且编译了一个新类，就会产生一个Class对象(是被保存在一个同名的.class文件中)。为了生成这个类的对象，运行这个程序的Java虚拟机将使用叫做类加载器的子系统。
  3.所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用的时候(构造器也算是静态方法)，就会加载这个类。因此Java程序在它开始运行之前并非被完全加载，其各个部分是在必需是菜加载的。
  4.类加载器首先检查这个Class对象是否已经加载，如果还没有加载则默认的类加载器就会根据类名查找.class文件。一旦某个类的Class对象被载入内存，则它就被用来创建这个类的所有对象。
  5.Class的API：
    (1)Class Class.getName(String name):Class的静态方法，参数为String类型的类名，返回一个指向此类的引用(指向此类的Class引用)，如果此类没有被加载则立刻加载此类，如果找不到此类定义，则抛出ClassNotFoundException异常。
    eg：
    Class.forName("Gum");  ----  如果Gum已经被加载则返回该类的Class引用，如果没有被加载则立刻被加载并返回引用，如果找不到该类的定义则抛出异常。
    (2)String .getName()：返回该类的全限定类名
    (3)String .getSimpleName()：返回不包含包名的类名
    (4)String .getCanonicalName()：返回全限定名
    (5)boolean .isInterface()：判断该Class对象是否为接口，如果是则返回true，反之返回false
    (6)Class(class[]) .getInterface()：返回该Class对象所继承的接口(如果继承多个接口也可以返回)。
    eg：
    for(Class c:a.getInterface()){  ----  当a对象的类继承了多个接口的时候则使用foreach进行循环
    	//...
    }
    (7)Class .getSuperClass()：返回该对象的上一层基类Class。
    (8)Object .newIntance()：如果该类有默认构造器的时候，则可是使用这个方法强制正确创建一个实例(虚拟构造器)，这个方法会调用类型的默认构造器，并且返回类型为Object(不使用泛型的时候)，在使用具体方法时需要进行向下转型。
  14.2.1 类字面常量
    1.可以使用.class创建一个类型的Class的引用，而且这样做不会引发该类的初始化。
    eg：
    Class cls = String.class;  ----  不会引发String对象的初始化
    2!.为了使用类而准备的工作：
      (1)加载：由类加载器执行，将查找字节码(在classpath所制定的路径中查找)，并从字节码中创建一个Class对象。
      (2)链接(分配储存空间)：在链接阶段将验证类中的字节码，为静态区域分配储存空间，如果必需的话将解析这个类创建的对其他类的所有引用。
      (3)初始化(初始化该储存空间)：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。
    3.编译器常量：同时用static和final修饰的常量(注意是常量)。会不依赖类的初始化而被访问。
    4.如果一个static与域不是final的，则对其进行访问的时候，总是要求它在被读取之前就进行链接和初始化。
    5.eg：
      class A{
      	static final int a1 = 47;
      	static final int a2 = B.getNum();
      }
      class B{
      	int getNum(){
      		return 5;
      	}
      }
      class C{
      	static int c1 = 4;
      }
      ....
      Class aa = A.class;  ----  不会触发初始化，因为是编译器常量
      System.out.println(A.a1);  ----  不会触发出发初始化，因为是编译器常量
      System.out.println(A.a2);  ----  会触发A和B的初始化，尽管a2被static和final同时修饰，但是a2不是编译器常量，所以访问会触发初始化
      System.out.println(c1);  ----  会出发C的初始化，因为访问了C的静态区域。
    6.基本类型的.class指向其包装类
  14.2.2 泛化的Class引用
    1.Class引用总是只想某个Class对象，它可以制造实例(.newInstance())，并且包含可作用于这些实例的所有方法代码。还包含该类的静态成员。所以Class引用就是表达它所指向的对象的确切类型，该对象便是Class类的一个对象。
    2.可以对Class所指向的类型进行更具体的限制(使用泛型)，而限定了类型的Class引用只能指向限定的类型
    eg：
    Class intClass = int.class;  ----  指向Integer的普通Class引用
    Class<Integer> genericIntClass = int Class;  ----  限定了类型的Class引用，只能指向Integer类或者Integer类的子类
    int Class = double.class;  ----  通过编译，因为普通Class没有限制类型，可以将其引用指向另一种类型
    //genericIntClass = double.class;  ----  无法通过编译，因为已经限定了类型。
    3.普通Class引用的更好的版本，Class<?>，?代表通配符。将通配符放在泛型中表示任何类型。与Class相比这代表着我是用Class<?>并且碰巧。
    Class intClass = int.class;
    Class<?> intClass = int.class;  ----  两者是等价的
    4.使用通配符与泛型结合可以生成只能指向一个范围的Class对象(泛型内的对象以及对象的子类或者超类)：
    eg：
    Class<? extends Number> a = int.class;  ----  Class引用被限定为Number类型或者继承自Number的类型
    Class<? super Integer> b = Number.class;
    a = double.class;  ----  符合限定的类型的条件，通过编译
    a = Number.class;  ----  符合限定的条件，通过编译
    //Class<Number> b = int.class;  ----  不能通过编译，因为即使Integer继承自Number，但是Integer.class并不继承自Number.class(我是这么理解的不知道对不对)。
    5.向Class引用添加这种泛型语法的原因仅仅是为了提供编译器类型检查(不添加的话如果出错会在运行时得到)。
    6.在加入了明确限定类型的Class对象使用.newInstance()会返回确切类型，如果你手头有一个超类，编译器只允许你声明<? super A>而不允许你使用确切的超类类名(??不知道为啥)。
    Class A{}
    Class B extends A{}
    eg：
    Class<B> b = B.class;
    B bb = b.newInstance();  ----  因为使用了明确的限定类型，所以通过编译
    Class<? super B> b1 = b.getSuperClass();  ----  通过编译
    //Class<A> b1 = b.getSuperClass();  ----  不会编译，只允许使用<? super B>
    Object obj = b1.newInstance();  ----  因为<? super B>的模糊性所以这里只能返回Object而不能返回确切的类型。
  14.2.3 新的转型语法
    1.普通转型语法：
    eg：
    class A{}
    class B extends A{}
    ....
    A b1 = new B();
    B b2 = (B)b;  ----  向下转型，向上转型不需要声明
    2.使用class的转型方法：用于在只持有Class对象时进行转型(非常罕见)
    A b1 = new B();
    Class<b> B_Type = b.class;
    B b2 = B_Type.cast(b1);  ----  将b1的类型(A)向下转型为B(B_Type的类型)
14.3 (深奥)转型转换钱先做检查
  1.RTTI在编程中的形式：
    (1)传统的类型转换，使用()在变量前面进行类型转换(向下转型)：在编译期检查的类型一般都是向下转型，因为向上转型，编译器知道子类一定是基类，所以不提供显式转型操作。但是向下转型并不确定(可能有很多种子类)，所以需要转型操作以告知额外的信息。
    (2)代表对象类型的Class对象。通过查询Class对象可以获取运行时所需的信息。
    (3)关键字instanceof，返回布尔值，告诉我们对象是不是某个特定类型的实例。左侧为具体的对象，右侧为具体的类型(右侧只能为具体的类型，不能为Class对象)
    eg：
    if(pet instanceof Pet){  ----  如果pet属于Pet类
    	//...
    }
    14.3.1 使用类字面常量
      1.在某些情况下使用类字面常量代替.forName()会使代码简化。
    14.3.2 动态的instanceof
      1.Class对象可以调用.isInstance()括号内为对象。可以判断该Class对象是否属于括号里的对象的类型。在很多方面都可以简化instanceof的代码。
      2.Map的预加载：MapData.map(List,int)第一个参数为List，后一个参数为int值，最后的结果就是将左侧List的每一项作为一个键，对应的value为右侧的int值。用在Map的构造函数中。
      eg：P323
    14.3.3 递归计数
      1?.对class对象使用isAssignableFrom()括号内为一个Class对象，如果前者可以从后者导出，则返回true，反之返回false。
14.4 （深奥）注册工厂
  1.工厂方法的实质就是让对象以自己的方式创建自己，而程序员可以操作的是生成对象的工厂。(在书中实例是将不同类型的工厂放在List中然后随机生成)
  eg：P331
14.5 instanceof与Class的等价性
  1.用instanceof(.isInstance())进行比较的结构考虑了相同的类以及子类。但是根据.equals()进行比较则不会考虑继承，但是却可以判断出是否为相同的类。
14.6 （放弃。。）反射：运行时的类信息
  1.如果不知道某个对象的确切类型，RTTI可以告诉你。但是有一个限制：这个类在编译的时候必须已经知道了，这样才能使RTTI识别它，并且利用这些信息做一些有用的事情。即编译器必须知道所有要通过RTTI来处理的类。
  2.反射类库提供了Field，Method，Constructor类库来使匿名对象的类信息在运行时被完全确定下来。
  3.对于RTTI来说，编译器在编译时打开和检查.class文件。对于反射来说，.class在编译时是不可获取的，所以是在运行时打开和检查.class文件。
  14.6.1 类方法提取器
    1.eg：P336
14.7 （彻底放弃。。）动态代理
  1.完全看不懂，我这个小白可以放弃这里了。吧这里留在以后深入研究设计模式的时候再使用。
  2.虽然看不懂但是我能知道动态代理使用了Proxy类。
14.8 空对象
  1.使用一个空接口用来代表空：Null。再使用具体类继承自这个接口，以表达具体类别的空！这样在实际操作时，不用检测对象是否够为null，而可以对所有对象都进行正常的操作。
  2.空对象都是单例的。
  eg：
  public interface Null{}
  class Person{  ----  需要一个与人相关的对象
  	...
  	public static class NullPerson extends Person implements Null{  ----  内部静态类，继承需要的对象(Person)，实现Null接口
  		private NullPerson(){super(...)}  ----  对应的对象Person的空构造器
  		public toString(){...}  ----  实现toString以便在打印时可以将NullPerson当作正常对象一样处理
  	}
  	public static final Person NULL = new NullPerson();  ----  空对象是单例的，所以加上final(这就好比声明了一个int类的flag)
  }
  3.如果你用接口取代具体类，那么就可以使用DynamicProxy来自动创建空对象。
  14.8.1 模拟对象与桩
14.9 接口与类型信息
  1!!!.使用反射可以访问并调用所有域的方法或者是字段！！！除了修改final变量！！！
14.10 总结
  1.面向对象编程语言的目的是让我们在凡是可以使用多态机制的地方都使用多态。
  2.当基类是由别人控制的时候(自己无法添加新特性的时候)，可以自己创建一个基类，然后将自己的类型继承自这个基类。在与原类型进行协作的时候使用RTTI进行类型检查，以区分自己的新类和他人的类使用时的差别。
  3.当某个子类需要效率优化的时候，可以使用RTTI针对某个子类进行特别的操作。
  4.反射必须有时间好好研究一下。

第十五章 泛型

15.1 与C++的比较
15.2 简单泛型
  1.eg：
  class A<T>{  ----  T为类型参数，这个对象中的T类型可以在你创建它时确定下来。(例如容器类，当你真正使用容器的时候你才能确定装进去的确切类型)
  	private T t;
  }
  15.2.1 元组
    1.当方法返回多个值得时候可以使用元组。元组中储存的元素具有只能读取不能修改的特点。
    eg：
    public TwoTuple<A,B>{
    	public final A a;  ----  虽然是public的但是由于final所以不能修改。想要得到不一样数据的元组，需要额外创建一个新的元组
    	public final B b;
    	public TwoTuple(A a,B b){
    		this.a = a;
    		this.b = b;
    	}
    }
    ....
    public TwoTuple<String,Integer> getResult(){
    	return new TwoTuple<String,Integer>("abc",3);
    }
    3.通过继承可以轻易的扩展元组内元素的个数：
    eg：
    public ThreeTuple<A,B,C> extends TwoTuple<A,B>{
    	public final C c;  ----  额外扩展的元组
    	public ThreeTuple(A a,B b,C c){
    		super(A a,B b);  ----  调用基类的构造函数。
    		this.c = c;
    	}
    }
15.3 泛型接口
  1.泛型也可以应用在接口上。接口使用泛型与类使用泛型没什么不同。
  eg：例子是生成器的设计模式(与Iterable接口使用可以产生常用的类)
  public interface Generator<T> {
  	T next();
  }
  eg：
  public class CoffeeGenerator implements Generator<Coffee>,Iterable<Coffee>{
  	...
  	public Coffee next(){
  		//...  ----  实现Generator接口的方法
  	}
  	class CoffeeIterator implements Iterable<Coffee>{
  		public boolean hasNext(){
  			//...
  		}
  		public void remove(){
  			//not implemented
  		}
  		public Iterator<Coffee> iterator(){  ----  返回一个迭代器。
  			return new CoffeeIterator();
  		}
  		public Coffee next(){
  			//...
  		}
  	}
  }
  2.泛型的局限性：不能使用基本类型，但是已经通过自动包装机实现。(自动打包自动拆包)
  3.适配器：其实就是某个类为了实现某接口但是还不想重写这个类，就弄一个新类继承自原始类然后implements需要的接口，通过原始类的接口的各种逻辑操作组合成新的接口以供使用。
15.4 泛型方法
  1.类中的方法同样可以使用泛型，但是这个方法所在的类可以是泛型的也可以不是泛型的。也就是说，是否拥有泛型方法与其所在的类是否是泛型的是没有关系的。
  2.static没法访问类中的泛型参数，所以如果static方法中要使用泛型，要将static变成泛型方法。
  3.方式：在返回值之前声明泛型
  eg：
  public <T> void f(){  ----  <T>的声明在返回值之前
  	//...
  }
  4.使用原则：如果通过声明泛型方法就可以解决的事情，请尽量不要使用泛型类。
  5.在创建泛型对象的时候，必须指明泛型的类型(使用尖括号)。但是使用泛型方法的时候，则不用(就像正常方法使用，更像一个被无限次重载的方法)，这种编译器自动识别泛型的能力就是类型推断。
  15.4.1 杠杆利用类型参数推断
    1.可以设置一个简化代码的工具集：
    public class New{
    	public static <K,V> Map<K,V> map(){
    		return new HashMap<K,V>();
    	}
    }
    ....
    Map<Person,List<? extends Pet>> map = New.map();  ----  虽然我们可以不用再重新写一遍尖括号中的泛型，但是在阅读代码的时候依然需要查看工具集，所以简化效果不怎么地。
    2.类型推断只对赋值操作有效，其他时候不起作用：将一个泛型方法调用的结果作为参数，传递给另外一个方法，这时编译器并不会执行类型推断，它会认为调用泛型之后返回值为Object。
    eg：
    class Test{
    	public static void f(Map<Person,List<? extends Pet>>){}
    }
    ....
    //f(New.map());  ----  不会通过编译，不会进行类型推断
    3.为了解决以上问题，可以在操作符“.”与方法名之间加上尖括号内的具体泛型，类内的方法需要使用this.<>method，静态方法需要ClassName.<>method：
    eg：
    f(New.<Person,List<? extends Pet>>map());  ----  通过编译
  15.4.2 可变参数列表与泛型
    1.可变参数列表能与泛型很好的共存：
    eg：
    public static <T> List<T> makeList(T... args){
    	list<T> result = new ArrayList<T>();
    	for(T item:args){
    		result.add(item);
    	}
    	return result;
    }
  15.4.3 用于Generator的泛型方法
    1.利用生成器可以很方便的填充一个Collection：
    eg：
    public static <T> Collection<T> fill(Collection<T> coll,Generator<T> gen,int n){
    	for(int i=0;i<n;i++){
    		coll.add(gen.next);
    	}
    	return coll;
    }
    ....
    Collection<Coffee> coffee = fill(new ArrayList<Coffee>(),new CoffeeGenerator(),4);
    Collection<Integer> number = fill(new ArrayList<Coffee>(),new Fibonacci(),12);
  15.4.4 一个通用的Generator
    1.下面的程序可以为任意类构造一个Generator(只要该类具有默认构造器)。为了减少类型声明，它提供了一个泛型方法，用以生成BasicGenerator：
    public class BasicGenerator<T> implements Generator<T>{
    	private Class<T> type;
    	public BasicGenerator(Class<T> type){this.type = type;}
    	public T next(){
    		try{
    			return type.newInstance();
    		}catch(Exception e){
    			throw new RuntimeException(e);
    		}
    	}
    	public static <T> Generator<T> create(Class<T> type){
    		return new BasicGenerator<T>(type);
    	}
    }
    必须满足两个条件：
      (1)想要创建的类必须是public的
      (2)必须具有默认构造器，因为要使用.newInstance();
    15.4.5 简化元组的使用
      1.通过重载static方法简化元组的使用：
      eg：
      public class Tuple{
      	public static <A,B> TwoTuple<A,B> tuple(A a,B b){
      		return new TwoTuple<A,B>(a,b);
      	}
      	public static <A,B,C> TwoTuple<A,B,C> tuple(A a,B b,C c){
      		return new TwoTuple<A,B,C>(a,b,c);
      	}
      	...
      }
      ....
      class Test{
      	static TwoTuple<String,Integer> f(){
      		return tuple("hi",123);
      	}
      	static TwoTuple f2(){
      		return tuple("h1",123123);
      	}
      }
      ....
      System.out.println(f2());  ----  不会报错，因为f2()返回的并是非参数化的TwoTuple对象。
    15.4.6 一个Set实用工具
      1.用set表示数学中的关系式
      eg：
      public class Sets{
      	public static <T> Set<T> union(Set<T> a,Set<T> b){
      		Set<T> result = new HashSet<T>(a);  ----  通过复制a，用a创建一个全新的Set，所以不会改变a本身的值。以下方法都是这样。
      		a.addAll(b);
      		return result;
      	}
      	public static <T> Set<T> intersection(Set<T> a,Set<T> b){
      		Set<T> result = new HashSet<T>(a);
      		result.retainAll(b);
      		return result;
      	}
      	public static <T> Set<T> difference(Set<T> a,Set<T> b){
      		Set<T> result = new HashSet<T>(a);
      		result.removeAll(b);
      		return result;
      	}
      }
15.5 匿名内部类
  1.泛型可以应用于匿名内部类
  eg：用匿名内部类实现Generator接口
  class A{
  	public static Generator<A> genertor(){  ----  用一个方法返回接口类型以实现接口
  		return new Generator<A>{  ----  返回一个接口类型并在匿名类中进行实现
  			public A next(){ return new A(); }  ----  实现这个接口，用于生成本类的实力
  		}
  	}
  }
  class B{
  	public static Generator<B> generator = new Generator<B>{  ----  储存一个public,static的接口类型的字段，使用匿名类对其进行实现，使其在静态初始化的时候就可以返回本类的实例。
  		public B next(){ return new B(); }
  	};
  }
15.6 构建复杂模型
  1.创建List元组(List中的每一个元素都是一个元组)
  eg：
  public class TupleList<A,B,C,D> extends ArrayList<FourTuple<A,B,C,D>>{  ----  一继承就完事了，其实就是一个ArrayList只是通过继承将要输入的参数化类型简化了而已

  }
  ....
  TupleList<A,B,C,D> t1 = new TupleList<A,B,C,D>();  ----  因为这东西就是一个ArrayList所以这里可以直接使用相应的方法
  t1.add(a,b,c,d);
  2.利用泛型实现多层嵌套容器(超市管理容器嵌套)：
  eg：
  class Product{
  	public static Generator<Product> generator = new Generator<Product>(){  ----  用于生成Product
  		public Product next(){
  			return new Product();
  		}
  	}
  }
  class Shelf extends ArrayList<Product>{
  	public Shelf(int product){
  		Generators.fill(this,Product.generator,product);  ----  调用Product.generator接口中的实现，创建product个Product实例，并且添加到本类的ArrayList<Product>中
  	}
  }
  class Aisle extends ArrayList<Shelf>{
  	public Aisle(int shelf,int product){
  		for(int i=0;i<shelf;i++){  ----  循环产生shelf的ArrayList<Product>
  			add(new Shelf(product));
  		}
  	}
  }
  public class Store extends ArrayList<Aisle>{
  	public Store(int asile,int shelf,int product){
  		for(int i=0;i<asile;i++){
  			add(new Aisle(shelf,product));  ----  与上面的生成逻辑一样，最终会生成一个Store对象，里面有asile个过道，每个过道有shelf个架子，每个架子有product个物品(product由接口随机生成)
  		}
  	}
  }
15.7 擦除
  1.Java泛型是使用擦除来实现的，意味着当你在使用泛型的时候，任何具体的类型信息都被擦除了。唯一知道的就是你在使用一个对象。所以List<Integer>和List<String>在类型上完全一样(都是List类型，可以通过Class对象进行判断)
  2.在泛型代码内部，无法获得任何有关泛型参数类型的信息。这意味着无法通过传进来泛型而使用泛型类型的方法。
  3。.getTypeParameters()(Class对象的方法)，并不能返回泛型的具体类型。
  4.C++的泛型是可以获取到参数类型的。
  15.7.1 C++的方式
    1.C++的泛型类中，可以直接调用类中的参数化类型对象的方法，编译器会进行检查，对应类型是否包含相应方法，如果没有则报错。但是java中由于擦除得不到参数化类型的任何信息，所以也就无法调用参数化类型的方法。
    eg(C++)：
    template<class T> class A{
    	T obj;
    public:
    	Manipulator(T x){obj = x;}
    	void mainpulate(){
    		obj.f();  ----  此句在java中会编译错误，可以使用其他方法进行调用。
    	}
    }
    2.泛型定界：
    可以重用extends对泛型的擦除划定一定的界限，使泛型成为继承自某一基类的任意类型，这样参数化类型的对象就可以随意调用此基类下的方法。
    eg：
    class Manipulator2<T extends HasF>{
    	private T obj;
    	public Manipulator2(T x){ obj = x; }
    	public void manipulate(){
    		obj.f();  ----  可以通过编译，因为参数化类型进行了定界。
    	}
    }
    编译器实际上会把类型参数替换为它的擦除，本例中T擦除到了HasF，就好像在类的声明中使用HasF替换了T一样
    3.与不使用泛型的对比:
      (1)只有当你希望使用的类型参数比某个具体类型(以及他的所有子类型)更加泛化的时候(希望代码能跨越多个类进行工作的时候)
      (2)如果某个类中有一个返回T的方法，那么泛型就有所帮助，因为它们最后能返回确切的类型！(使用<T extends Base>可以返回具体的子类)。
    eg：
    class Manipulator3{
    	private HasF obj;
    	public Manipulator3(HasF x){obj=x;}
    	public void manipulate(){obj.f();}
    	public HasF get(){
    		return obj;  ----  即使obj实际上为HasF的子类，但是这里依然只会返回基类类型HasF
    	}
    }
    eg：
    class A<T extends B>{
    	private T obj;
    	public A(T x){obj=x;}
    	public T get(){
    		return obj;  ----  返回具体的T的子类类型
    	}
    }
  15.7.2 迁移兼容性
    1.如果Java 1.0中就有泛型则会将其支持的很好(不使用擦除)。但是泛型并且刚开始就属于java的一部分。
    2.在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能再重要的上下文环境中使用的类型。
    3.泛型类型只有在静态类型检查期才出现，之后程序中的所有泛型类型都将被擦除，替换为他们的非泛型上界。普通变量在未指定边界的时候将被擦除为Object。
    4.java中使用擦除实现泛型的原因是向下兼容。修改过的类必须不具备探测其他类库是否使用了泛型的能力，所以某个特定类库使用了泛型这样的证据必须被擦除。(从非泛化的代码到泛化代码的转变过程)
  15.7.3 擦除的问题
    1.泛型不能显示的引用运行时类型(RTTI)的操作之中：转型，instanceof,new表达式。
    2.泛型不能使用<?>(Class可以使用<?>)
    eg：
    class A<T>{}
    class B<T> extends A<T>{}  ----  通过编译
    class C extends A{}  ----  不会立刻发出警告
    class D extends A<?>  ----  编译错误，找不到边界
  15.7.4 边界处的动作
    1.泛型在类中的可能出现的错误
    eg：
    public ArrayMaker<T>{
    	private Class<T> kind;
    	T[] create(int size){
    		return (T[])Array.newInstance(kind,size);  ----  这句的kind实际储存起来只是一个Class对象不带有任何类型参数的信息，所以newInstance()实际上没有Class的实际信息
    	}
    }
    2.即使擦除在方法或者类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或者类中使用的类型的内部一致性。
?15.8 擦除的补偿
  1.擦除丢失了在泛型代码中执行某些操作的能力。任何在运行时需要知道确切类型信息的操作都将会无法工作。
  15.8.1 创建类型实例
    1.创建参数化类型实例的时候需要用到工厂模式：
    eg：
    interface Factory<T>{
    	T create();
    }
    class Foo2<T>{
    	private T x;
    	public <F extends Factory<T>> Foo2(F factory){
    		x = factory.create();
    	}
    }
    class IntegerFactory implements Factory<Integer>{
    	public Integer create(){
    		return new Integer(0);
    	}
    }
    ...
  15.8.2 泛型数组
    1.不能创建泛型数组，解决方案是在想要创建泛型数组的时候都使用ArrayList。
    ...
15.9 边界
  1.可以通过边界让输入类型具有超过普通继承的复杂性：
  eg：
  class B{}
  interface C{}
  class A<T extends B&C>{  ----  B为一个类，C为一个接口，T必须同时满足这两种要求才能够创建A。其中要注意在extends后面使用&时，必须类名在前接口名在后。
  }
15.10 通配符
  1.关于数组的问题：
  eg：
  class Fruit{}
  class Apple extends Fruit{}
  class Orange extends Fruit{}
  class SmallApple extends Apple{}
  ....
  Fruit[] fruit = new Apple[10];  ----  数组引用是Fruit，但是实际对象是Apple
  fruit[0] = new Apple();  ----  添加Apple对象没问题
  fruit[1] = new SmallApple();  ----  添加Apple的子类没问题
  fruit[2] = new Fruit();  ----  编译器可以通过，但是无法执行，因为实际对象是Apple
  fruit[3] = new Orange();  ----  编译器可以通过，但是无法执行，因为实际对象是Apple
  2.使用泛型数组发生相同的问题时：
  eg：
  //List<Fruit> fruit = new List<Apple>();  ----  不会通过编译，Apple的List在类型上不等价于Fruit的List(因为各自持有对象的类型不同)
  List<? extends Fruit> flist = new ArrayList<Apple>();  ----  通过编译，但是无法向其中.add()任何对象(根本不知道容器要持有的类型，无法安全的向容器添加对象。但是可以使用Array.asList初始化)
  15.10.1
    1.如果泛型类中出入了<? extends A>参数，则类中所有将参数类型作为输入的方法全都不能用。
    eg：
    class A<T>{
    	public void set(T t){};
    }
    ....
    A<? extends Pet> a = new A<Dog>();
    //a.set(new Cat());  ----  不能使用这个方法，因为T是作为<? extends Pet>输入的，所以set就变为了.set(<? extends Pet>),无法确定其确切的类型，不能运行。
    2.如果创建了一个泛型，不能将其向上转型。但是利用通配符达到目的。
    eg：
    class A{}
    class B extends A{}
    ....
    //Holder<A> holder1 = new Holder<B>();  ----  报错，因为泛型中不能执行向上转型
    Holder<? extends A> = new Holder<B>();  ----  通过编译，但是如果返回的是泛型，则会返回Fruit(返回边界类型)，(注意与<T extends A>不同，<T extends A>的类中奖返回确切的类型而不是边界)
    15.10.2 逆变
      1.超类型通配符：<t super A>或者<? super a>。
      eg：
      public class Test{
      	static void writeTo(List<? super Apple> apples){
      		apples.add(new Apple());  ----  通过编译，因为Apple的超类成为了?并且变得不安全，所以其子类变得安全了
      		apples.add(new SmallApple());  ----  通过编译
      		//apple.add(new Fruit())；  ----  无法添加，原因同<? extends Apple>
      	}
      }
      理解：
      (1)<? extends A>：表示任何一个A的子类，具体是哪一个？不知道，所以作为参数是不行的，因为不知道所以不安全。
      (2)<? super A>：表示任何一个A的超类，具体是哪一个？不知道，但是不管是哪一个，A以及A的子类都继承自这个不知道的类，所以A和A的子类作为参数输入将变得安全(逆变)
      eg：
      T read(List<? extends T> list){  ----  将<? extends T>用作读取。
      	return list.get(0);  ----  将返回边界的T类型引用
      }
      T read1(List<? super T> list,T item){  ----  <? super T>用作写入
      	list.add(item);  ----  使用extends将不能使用.add()
      }
      2!.extends用于读取，返回后面的T类型。super用于写入
    15.10.3 无界通配符
      1.捕获转换(真看不下去了)。。。
      2.P397
15.11 使用泛型会遇到的问题
  1.泛型中不能使用基本类型(不会自动包装，需要手动使用包装类)
  2.一个类不能实现同一个泛型接口的两种变体，由于擦除他们会被擦除成为一个相同的类
  eg：
  interface A<T>{}
  class B extends A<Type1>{}
  //class C extends A<Type2>{}  ----  无法编译，擦除只会识别出来A<>
  3?.使用泛型类型参数的转型或者instanceof不会有任何效果。（需要继续研究）
  4.不同的泛型不能作为不同的参数类型作为重载
  eg：
  void f(List<T> v){}
  void f(List<V> a){}  ----  这两个都是相同的参数签名
  5.基类劫持了接口：
  class A implement I<B>{}  ----  基类实现了一个有着具体参数类型的接口，
  //class C extends A implement I<D>{}  ----  子类可以继承，但是不能implements具有不同参数类型的接口
  class E extends A{}  ----  可以直接继承，然后将A中实现的接口函数进行覆写
15.12 自限定类型
  1.(无视)P404
15.13 动态类型安全
  1.容器类包含特定API可以对泛型容器的类型进行强制检查(用于兼容以前的原生容器)
15.14 异常
  1.由于擦除的原因，泛型使用到异常中非常受限。catch语句不能捕获泛型的异常。泛型类也不能直接或者间接继承自Throwable。
15.15 混型
  1.混型：混合多个类，以产生一个可以表示混型中所有类型的类。(C++模板类可以获得泛型的确切类型，也能够调用泛型的方法，所以一个有着特定类型的泛型类可以算作是泛型类型的继承类(不能实现)，因为可以重新调用其方法。)
  2.java中不支持继承一个泛型参数。
  15.15.2 与接口混合
    1.虽然java中不能使用混型，但是可以通过与混型效果。
    2.通过代理接口类型的对象，达到混型的效果。
    eg：
    interface A{
    	void a();
    }
    interface B{
    	void b();
    }
    class AA implements A{
    	public void a(){}
    } 
    class BB implements B{
    	public void b(){}
    }
    class HunXing implements A,B{  ----  implements两个接口
    	private A a = new AA();  ----  使用代理模式，持有接口类型的对象，用对象的接口方法当作接口的方法体
    	private B b = new BB();
    	public void a(){
    		return a.a();
    	}
    	public void b(){
    		rerturn b.b();
    	}
    }
  15.15.3 装饰器模式
    1.装饰器模式是对混型的一种又局限的解决方案
    2.P414
  15.15.4 与动态代理混合
    1.(无视)
15.16 潜在的类型机制
  1.(无视)
15.17 对潜在类型机制的补偿
  1.(无视)P420
15.18 (无视)

第十六章 数组

16.1 数组为什么特殊
  1.数组与其他容器类的三个区别：效率，类型，保存基本类型的能力。
    (1)数组的效率最高，但是付出的代价就是数组对象的大小被固定，且在其生命周期中不可变。
    (2)数组只能持有一种具体类型。
    (3)数组可以持有基本类型(java5之后容器也可以通过自动包装持有基本类型)
16.2 数组是第一级对象
  1.数组是对象，length是数组对象中几乎唯一可以访问的字段。
  2.[]语法是访问数组对象的唯一方式。
  3.持有基本类型时候，数组储存的是实际的值。持有对象时，数组持有的是引用。
  4.数组的多种初始化方式：
  eg：
  A[] a = new A[5];  ----  创建一个size为5的A对象，未进行初始化之前所有其中的对象都置为null
  A[] a1 = {new A(),new A(),new A[]};  ----  创建size为3的A对象数组，并且初始化
  A[] a2 = new A[]{new A(),new A(),new A()}  ----  与上一句一样
  a = a1;  ----  就是引用之间的相等，现在a,a1都指向相同的数字对象(a1所指向的数组对象)
16.3 返回一个数组
  1.C++中不能返回数组，但是java中可以返回。
16.4 多维数组
  1.基本类型的多维数组：
  eg：
  int[][] a = {
  	{1,2,3},
  	{4,5,6},
  };
  System.out.println(Arrays.deepToString(a));  ----  Array.deepTpString(a)将多维数组转换为多个String方便输出
  int[][][] a = new int[2][2][4];  ----  使用new来分配多维数组，可以确定size。
  2.对象的多位数组：
  eg：
  A[][] a = {
  	{new A(),new A()},
  	{new A()},
  }
  System.out.println(Array.deepTpString(a));  ----  deepToString()对对象同样生效，会调用对象的toString()方法
16.5 数组与泛型
  1.通常情况下数组不能与泛型一起工作(泛型会擦除具体的类型，但是数组必须确切的知道他们)
  eg：
  //A<B> ab = new A<B>[10];  ----  不合法
  2.可以参数化数组本身
  eg：
  class A<T>{
  	public T[] f(T[] arg){return arg;}
  }
  3.利用转型：
  class A<T>{
  	T[] array;  ----  虽然不能直接创建，但是声明其引用是可以的
  	public T[] a(){
  		//array = new T[5];  ----  非法
  		array = (T[])new Object[5];  ----  通过对Object的转型可以实例化
  	}
  }
16.6 创建测试数据
  16.6.1 Array.fill()
    1.Array.fill()：将同一个值填充到各个位置，如果是对象，则将复制其引用到各个位置。
    eg：
    int[] a = new int[10];
    Array.fill(a,0);  ----  所有都是0
    String[] a1 = new String[10];
    Array.fill(a1,"hehe");  ----  全都是hehe
    Array.fill(a1,3,5,"haha");  ----  在刚才a1的基础上，将索引为3到5的元素fill为“haha”
  16.6.2 数据生成器
    1.P443
16.7 Arrays实用功能
  1.Arrays中有一些使用的static方法：
    (1)Arrays.equals():比较两个数组是否相等。(deepEquals()用于对多维数组进行比较)
    (2)Arrays.sort():对数组进行排序
    (3).binarySearch():在已经排序的数组中查找元素。
    (4).toString():产生数组的String表示。
    (5).hashCode():产生数组的散列码
    (6)asList():接受任意序列或者数组，转变为List
  16.7.1 复制数组
    1.System.arraycopy():对数组进行复制，速度比for要快
    eg：
    int[] i = new int[7];
    int[] j = new int[10];
    Arrays.fill(i,55);
    Arrays.fill(j,98);
    System.arraycopy(i,0,j,0,i.length);  ----  从i的第0元素开始，向j的第0个元素复制i.length个i数组中的元素(发生变化的数组是j)
    输出：
    j={55，55，55，55，55，55，55，98，98，98}
    2.System.arraycopy()如果对对象进行复制，则只是复制其引用(浅复制)
    3.System.arraycopy()中没有自动包装功能，只能使用确切的类型。
  16.7.2 数组的比较
    1.Arrays.equals()，两个数组相等的条件是，两个数组的size相同，且对应元素也相同。对应元素上的比较是调用每个元素的.equals()进行判断的。(基本类型则调用包装类的.equals())
  16.7.3 数组元素的比较
    1.使用Comparable<T>接口：
    eg：
    class A implements Comparable<B>{
    	...
    	comparaTo(B b){  ----  此函数接受一个Object对象，当前对象小于参数，返回负值，大于则返回正值，相等则返回0
    		//...
    	}
    }
    2.任何实现了Comparable<>接口的对象如果放在数组中都可以通过.sort()方法对其进行排序
  16.7.4 数组排序
    1..sort()进行排序：对对象使用稳定递归排序，对基本类型使用快速排序。
  16.7.5 在已排序的数组中查找
    1.使用binarySearch(a,b)；a表示需要查找的数组，b表示查找的值。返回的值是-插入点-1(插入点是第一个大于查找对象的元素)，意思是所有元素都小于参数，则返回a.size()。找到了则返回大于等于0的正值。
    2.必须应用在已经排好序的数组上，不然结果可能出错。
    3.只能用于不重复的排好序的数组中，如果想要处理有重复数据的序列，可以使用TreeSet。

第十七章 容器深入研究
  
17.1 完整容器分类法
17.2 填充容器
  1.Collections.fill()和Collections.nCopies():
  eg：
  List<String> list = new ArrayList<String>(Collections.nCopies(4,new String("hehe"));  ----  在构造器里面填充四个String对象
  Collections.fill(list,new String("haha"));  ----  List中的所有对象都替换为"haha"
  17.2.1 一种Generator的解决方案
    1.P460
  17.2.2 Map生成器
    1.P462
!17.3 Collections的功能方法
  1.Map不是继承自Collection的
  2.Collection的API(Collections中的是关于Collection的静态方法)：
    (1)boolean add(T)：确保容器持有具有泛型T的参数，如果没有将此元素添加进容器，则返回false。(可选)
    (2)boolean addAll(Collection<? extends T>)：添加参数中的所有元素。只要添加了任意元素就返回true。(可选)
    (3)void clear()：移除容器中的所有元素(可选)
    (4)boolean contains(T)：如果容器中已经持有T类型的元素，则返回true。反之则返回false。
    (5)boolean containsAll(Collection<?>)：如果容器中含有所有元素，则返回true
    (6)boolean isEmpty()：容器中没有元素时返回true
    (7)Iterator<T> iterator()：返回一个Iterator<T>,可以用来遍历容器中的元素
    (8)Boolean remove(Object)：如果Object参数在容器中，则移除此元素的一个实例。如果确实做了移除的工作了的话，返回true。(可选)
    (9)boolean removeAll(Collection<?>)：移除参数中所有元素。有移除动作发生就返回true(可选)
    (10)Boolean retainAll(Collection<?>)：只保存参数中的元素。只要Collection发生了变化就返回true(可选)
    (11)int size()：返回容器中元素的数目
    (12)Object[] toArray()：返回一个数组，该数组包含容器中所有元素
    (13)<T> T[] toArray(T[] a)：返回一个数组，数组的类型与参数类型相同，而不是单纯的Object。
  3.Collection不包含.get()方法，因为Set继承自Collection，Set的.get()是其内部自己维护的。
  4.Collection的API中的可选的方法表示，你在实现自己的Collection时可以选择不实现他们，而是抛出UnsupportedOperationException异常
17.4 可选操作
  17.4.1 未获支持的操作
    1.最常见的Unsupport的操作都是由于固定尺寸的数据接口支持的容器。当你用Arrays.asList()将数组转换为List就会得到这样的容器。
    2.解决办法是应该将这种方式转换过来的List放在新的List对象的构造函数中，或者使用.addAll()以恢复List的扩展性
!17.5 List的功能方法
  1.List的API：
    (1).get(int index)：返回index处的对象
    (2).indexOf(a)：a为容器内的对象，返回此对象的索引值
    (3).iterator()：返回迭代器
    (4).listIterator()：返回List专用的迭代器
    (5).lastIndexOf(a)；a为容器内对象，返回最后一个与之匹配的对象的索引值
    (6).set(int ,a)；将int处的对象更新为a
  2.LinkedList的API：
    (1).addFirst(a)：将a对象添加到linkedList的顶部
    (2).getFirst()：从顶部取一个对象。
    (3).removeFirst()：从顶部移除一个对象
    (4).removeLast()：从底部移除
17.6 Set和储存顺序
  1.Set(interface)：
    (1)存入Set的元素都是唯一的，因为Set不保存重复元素。
    (2)加入Set的元素必须定义.equals()方法以确保对象的唯一性。
    (3)Set与Collection有着一样的接口
    (4)Set不保证维护元素的次序
  2.HashSet(推荐使用)：为快速查找而设计的Set，存入HashSet必须定义hashCode()。
  3.TreeSet：保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。元素必须实现Comparable接口。
  4.LinkedHashSet：具有HashSet的查询速度，切内部使用链表维护元素顺序。于是在使用迭代器遍历的时候，会按照元素插入次序显示。元素也要定义hashCode()。
  17.6.1 SortedSet
    1.SortedSet中的元素可以保证处于排序状态。这里的排序指的是对象的比较函数而不是插入次序(与LinkedHashSet的区别)
    2.SortedSet的API：
      (1)Comparator comparator()：返回当前Set使用的Comparator，或者返回null
      (2)Object first()：返回容器中的第一个元素
      (3)Object last()：返回容器中的最后一个元素
      (4)SortedSet subSet(fromElement,toElement)：返回两个参数之间的Set子集(左包含，右不包含)
      (5)SortedSet headSet(toElement)：生成Set的子集，由小于参数的元素组成
      (6)SortedSet tailSet(fromElement)：生成Set的子集，由大于或等于参数的元素组成
17.7 队列
  1.Queue：将元素从一端插入，从另一端抽出来。
  17.7.1 优先级队列
    1.使用Comparable对优先级进行排序。
  17.7.2 双向队列
    1.没有直接的类型支持，需要使用组合从LinkedList进行衍生。
!17.8 理解Map
  1.Map：
    (1)HashMap(推荐使用)：基于散列表的实现，插入和查询的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。
    (2)LinkedHashMap：类似HashMap，但是在迭代遍历的时候，取得键值对的顺序是其插入次序。只比HashMap慢一点，但在迭代访问时反而更快，因为使用了链表。
    (3)TreeMap：基于红黑树的实现。查看键，或者键值对时候会被排序(Comparable)。特点在于得到的结果是经过排序的。并且是唯一一个可以返回子集的Map(用subMap()返回一个子树)
    (4)WeakHashMap：弱键映射，允许释放映射所指向的对象。如果映射之外没有引用指向某个键，则此键可以被垃圾回收期回收。
    (5)ConcurrentHashMap：一种线程安全的Map，不涉及同步加锁。
    (6)IdentityHashMap：使用==代替.equals()对键进行比较的散列映射。专为解决特殊问题而设计。
  2.Map中，每个键都必须有.equals()方法，如果被用于散列还必须实现hashCode()，如果被用于TreeMap还有实现Comparable
  3.Map的API：
    (1)map.size()：返回size
    (2)map.keySet()：返回一个由Key组成的Set
    (3)map.values()：返回一个由值组成的Collection，如果对这个Collection进行修改，Map中的值也会改变。
    (4)map.putAll()
    (5)map.containsKey(Key):如果含有此key则返回true
    (6)map.containsValue(Value)
    (7)map.remove(Key)
    (8)map.clear()
    (9)map.isEmpty()
    (10)map.keySet().iterator().next()：对KeySet进行迭代
    17.8.2 SortedMap
      1.可以确保键处于排序状态，这使得它具有额外功能
      2.SortedMap的API：
        (1)Comparator comparator():返回当前Map使用的Comparator，或者返回null
        (2)T firstKey()：返回Map中的第一个键
        (3)T lastKey()：返回Map中的最后一个键
        (4)SortedMap subMap(fromKey,toKey)：生成参数之间的Map子集，(左包含右不包含)
        (5)SortedMap headMap(tokey)
        (6)SortedMap tailMap(fromKey)
    17.8.3 LinkedHashMap
      1.LinkedHashMap为了提高速度，散列化所有元素。但是在遍历键值对的时候，却又以元素的插入顺序返回键值对。
!17.9 散列与散列码
  1.散列过程：
    (1)有一个size非常大的确定大小的数组。
    (2)通过hashCode()计算出一个对象的hashCode，将hashCode经过一些处理之后作为下标存入上面的数组。
    (3)在查找对象的时候，对对象进行散列计算，然后从数组中直接提取对象(速度几乎是O(1))
    (4)散列数组中的每一个槽位可能会有冲突(因为数组大小固定)，可以在槽位中加入List，在List中再通过equals()对每一个元素进行匹配。
  2.equals()函数写法：
    (1)自反性：x.equals(x)一定是true
    (2)对称性：y.equals(x)与x.equals(y)结果相同
    (3)传递性：x.equals(y)是true，y.equals(z)是true，则x.equals(z)也一定要是true
    (4)一致性：x,y中的信息没有改变的情况下，调用多少次.equals()结果都应该一样。
    (5)对任何不适null的x：x.equals(null)必须是false
  eg：
  class A{
  	int a;
  	String b;
  	public boolean equals(Object o){  ----  三层等价关系
  		return o instanceof A &&  ----  第一层，类型
  		  b.equals(((A)o).b) &&  ----  第二层，是类中某一个域
  		  a==((A)o).a;  ----  第三层也是类中的某一个域
  	}
  }
  3.hashCode()函数写法：使用.equals()函数中用到的域进行散列(c为对应域的散列值)
  	(1)给int变量result赋值一个非0常量
  	(2)对每一个有意义的域a(.equals()函数用作比较的域)进行下面的操作：
      (1)boolean a: c=(a?0:1);
      (2)byte char short int a: c=(int)a
      (3)long a: c=(int)(a^(f>>>32))
      (4)float a: c=Float.floatToIntBits(f);
      (5)double a: long l = Double.doubleToLongBits(a); c=(int)(l^(l>>>32));
      (6)Object a: c=a.hashCode();
      (7)数组：对每个元素应用上诉规则
    (3)result = 37*result+c;  ----  对每一次散列都运算次表达式
    (4)返回result
    (5)对hashCode()进行检验，确保相同的对象有相同的hashCode值
    eg：
    class A{
    	int a;
    	String b;
    	public boolean equals(Object o){
    		return o instanceof A &&
  		     b.equals(((A)o).b) &&
  		     a==((A)o).a;
    	}
    	public int hashCode(){
    		int result = 17;
    		if(b!=null){
    			result = 37*result + b.hashCode();
    		}
    		result = result*37 + (int)a';
    		return result;
    	}
    }
17.10 选择接口的不同实现
  1.有时需要根据你使用容器之后进行的操作进行选择，因为不同容器进行相同操作有时具有不同的性能，所以尽可能选择对你使用的多的操作性能更好的容器。
  2.性能测试
  17.10.1 性能测试框架
    1.P499
  17.10.2 对List的选择
    1.LinkedList，ArrayList，Queue各操作性能对比：P505
  17.10.4 对Set的选择
    1.TreeSet，HashSet，LinkedHashSet的性能对比：P508
  17.10.5 对Map的选择
    1.TreeMap，HashMap，LinkedHashMap，IdentityHashMap，WeakHashMap的性能对比：P510
17.11 实用方法
  1.Colleations中的使用静态方法：P512
17.12 持有引用
  1.三种引用对象由强到弱排列：SoftReference>WeakReference>PhantomReference
    (1)SoftReference：用来实现内存敏感的高速缓存
    (2)WeakReference：为了实现规范映射，它不妨碍垃圾回收期回收映射的键值。
    (3)PhatomReference：用以调度回收前的清理工作。
  17.12.1 WeakHashMap
    1.用来保存WeakReference
17.13 Java 1.0/1.1容器
  17.13.4 BitSet
    1.如果想要访问大量的“开/关”信息，则应该使用BitSet。但是效率仅是对空间而言，速度比本地数组稍慢一点。

第十八章 Java I/O系统

18.1 File类
  1.File类既能代表文件名，也能代表一个文件夹下的所有文件名。如果是一个文件集，则需要使用list()返回一个字符数组。
  18.1.1 目录过滤器
    1.如果需要得到具有特定扩展名的文件(或者其他操作)，则需要用到目录过滤器
    2.使用FilenameFilter对象
    eg：
    File path = new File(".");
    String[] list;
    list = path.list(new FilenameFilter(){  ----  使用匿名类直接实现FilenameFilter中的策略accpet()--是list()方法使用时必须要实现的一个接口而已。
    	private Pattern pattern = Pattern.compile(args[0]);  ----  正则表达式，args[0]为在main函数中输入的参数，可以在命令行里对main函数进行输入。
    	public boolean accept(File dir,String name){
    		return pattern.matcher(name).matches();
    	}
    });
  18.1.2 目录实用工具
    1.看不懂因为涉及正则表达式不想看了
!!18.2 输入和输出
  1.流是java作为输入输出的概念，这个概念屏蔽了所有实际的I/O设备的操作细节。
  2.I/O类大致分为输入流和输出流：
    (1)任何继承自InputStream或者Reader派生而来的类都有一个read()方法，用于读取单个字节或者字节数组。
    (2)任何继承自OutputStream或者Writer派生而来的类都有一个write()方法，用于写单个字节或者字节数组。
  3.很少使用单一的类来创建流对象，而是通过叠合多个对象来提供所期望的功能(装饰器设计模式)
  4.所有输入类都继承次InputStream，所有输出类都继承自OutputStream
  18.2.1 InputStream
    1.用于将那些从不同数据源产生输入的类。
    2.InputStream子类：
      (1)ByteArrayInputStream：允许将内存的缓冲区当作InputStream
      (2)StringBufferInputStream：将String转换为InputStream
      (3)FileInputStream：用于从文件中读取信息
      (4)PipedInputStream：产生用于写入相关PipedOutputStream的数据，用于实现管道化。
      (5)SequenceInputStream：将两个或者多个InputStream对象转换为一个单一的InputStream
      (6)FilterInputStream：抽象类，是装饰器的接口
  18.2.2 OutputStream
    1.决定了输出所要去往的目标：字节数组，文件，管道。
    2.OutputStream子类：
      (1)ByteArrayOutputStream：在内存中创建缓冲区。所有送往流的数据都要放在这个缓冲区中。
      (2)FileOutputStream：将信息写入文件
      (3)PipedOutputStream：任何写入其中的信息都会自动作为相关PipedInputStream的输出，实现管道化。
      (4)FilterOutputStream：抽象类，装饰器的接口。
18.3 添加属性和有用的接口
  1.为了实现不同的功能组合，使用装饰器模式进行I/O操作，但是会加大代码的复杂度--必须创建许多类。
  18.3.1 通过FilterInputStream从InputStream中读取数据
    1.读取方法的开头都是read..(例如readByte(),readFloat())
    2.FilterInputStream类型：
      (1)DataInputStream：与DataOutputStream搭配使用。传送基本类型数据以及String。
      (2)BufferedInputStream：可以防止每次读取都得进行实际写操作。代表使用缓冲区。
      (3)LineNumberInputStream：跟踪输入流中的行好，可以调用getLineNumber()和setLineNumber(int)
      (4)PushbackInputStream：具有能弹出一个字节的缓冲区。因此可以将读到的最后一个字符回退。
  18.3.2 通过FilterOutputStream向OutputStream
    1.FilterOutputStream类型：
      (1)DataOutputStream：可以将各种基本类型以及String对象格式化输出到流中。然后任何机器上的任何DataInputStream都能够读取到他们。所有的写方法都是以write开头的(例如writeByte(),writeFloat())
      (2)PrintStream：用于产生格式化的输出。DataOutputStream处理数据的储存，PrintStream处理显示。
      (3)BufferedOutputStream：使用以避免每次发送数据都要进行实际的写操作。代表使用缓冲区可以调用flush()清空缓冲区。
18.4 Reader和Writer
  1.Reader和Writer提供兼容Unicode与面向字符的I/O功能：
    (1)InputStream和OutputStream这个两个类不会被取代。
    (2)InputStreamReader和OutputStreamWriter可以把InputStream和OuputStream转换为Reader和Writer
  18.4.1 数据的来源和去处
    1.尽量尝试使用Reader和Writer(这两者是面向字符的，用于国际化)，如果出现问题则可以使用InputStream或者OutputStream(这两者是面向字节的)。
    2.数据的来源和去处，新类旧类的对应关系P538。
18.5 自我独立的类：RandomAccessFile
  1.RandomAccessFile适用于由大小已知的记录组成的文件。可以使用seek()将记录从一处转移到另一处，或者读取或者修改记录。
!18.3 I/O流的经典使用方式
  1.缓冲输入文件：打开一个文件作于字符输入，用FileReader打开文件并且付给BufferReader构造器。
  eg：(不考虑异常抛出问题)
  BufferReader in = new BufferReader(new FileReader(filename));  ----  将FileReader读取的文件直接赋值给BufferReader的构造器
  String s;
  StringBuilder sb = new StringBuilder();
  while((s=in.readline())!=null){
  	sb.append(s+"\n");  ----  在每一句后面加上换行符，因为readline()会自动将换行符删掉。
  }
  in.close();  ----  显示调用更加安全
  2.从内存输入
  1.使用BufferedInputFile.read()来读入文件
  eg：
  StringReader in = new StringReader(BufferedInputFile.read("filename.java"));
  int c;
  while((c=in.read())!=-1){  ----  以int类型返回下一个字节，必须在后面进行类型转换才能正确显示。
  	System.out.println((char)c);
  }
  3.格式化的内存输入：
    1.格式化输入可以使用DataInputStream，因为他的面向字节的(reader是面向字符的)
  eg：
  DataInputStream in = new DataInputStream(new ByteArrayInputStream(BufferedInputFile.read("filename.java").getBytes()));  ----调用.getBytes()来返回一个字节数组给ByteArrayInputStream
  while(true){  ----  因为读入的是字节，所以所有输入都会合法返回，不能用返回值来判断是否结束。可以使用available()来查看还有多少可供存取的字符(while(in.available())...)
  	System.out.println((char)in.readByte());  ----  以字节方式读入，需要进行转型以显示。
  }
  4.基本的文件输出：
  eg：
  PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(file)));
  out.println("sss");
  out.close();
  !!!未完!!!

!!第二十一章 并发
21.1 并发的多面性
  1.使用并发时需要解决的问题有多个，而实现并发的方式也有很多种，并且在这两者之间没有明显的映射关系。
  2.并发解决的问题大体上可以分为速度和设计可管理两种。
!!21.2 基本的线程机制
  21.2.1 定义任务
    1.需要实现Runnable接口并编写run()方法即可。
    eg：
    class A implements Runnable{
    	private static int taskCount = 0;  ----  用来计算整个类的实例个数
    	private final int id = 0;  ----  使用final来计算任务的序号
    	...
    	public void doSomething(){};
    	public void run(){
    		doSomething();
    		Thread.yield();  ----  线程调度器，声明我已经执行完生命周期中最重要的部分了，可以将时间切换给其他任务了。
    	}
    }
    2.Runnable接口中的run()就是一个不同的方法，run()内部没有特殊的多线程机制。要实现线程行为，需要显示的将一个任务附着在线程上。
  !!21.2.2 Thread类
    1.将Runnable对象交给Thread对象的构造器：
    	Thread t = new Thread(new A());
    	t.start();  ----  先执行Thread类的初始化操作，然后调用A中的run()方法。
  !!21.2.3 使用Executor
    1.Executor可以对Thread进行管理，而简化并发编程。(线程池)
    2.Executor的使用，使用ExecutorService：
    eg：
    ExecutorService exec = Executors.newCachedThreadPool();  ----  要使用静态的方法创建线程池
    for(int i=0;i<5;i++){
    	exec.execute(new A());  ----  直接将实现了Runnable接口的类传入即可(不需要Thread)
    }
    exec.shutdown();  ----  在调用了.shutdown()之后，exec将阻止新的线程加入其中。
    3.不同类型的Executor
      (1)FixedThreadPool：可以将最大线程数量在创建对象时传入构造器，以预先执行线程数量分配。
      eg：
      ExecutorService exec = Executors.newFixedThreadPool(5);  ----  表示最大的线程数只有5.
      (2)SingleThreadExecutor：线程数量为1的线程池(也提供了一定的并发保证，在此线程池中吗，其他线程不会被并发调用)，但是当新的线程加入其中的时候，会进行排队，在前一个任务执行完毕之后，后一个排队的任务会进入相同的线程来执行。
      eg：ExecutorService exec = Executors.newSingleThreadPool();
  21.2.4 从任务中产生返回值
    1.Runnable接口不能在线程中返回值，需要在线程中返回值的时候需要用到Callable接口，并且实现call()方法。
    2.Callable接口接受一个参数类型，这个参数类型call()方法中需要返回的值的类型。
    3.Callable接口只能由Executor.submit()方法调用(在该方法中传入实现了call()的对象，call()会自动执行)，并且返回Future<>参数类型就是返回数据的类型。
    4.Future类型具有isDone()函数用来判断结构是否已经计算完毕了。还可以使用.get()来获取结果，如果结果没有计算完成则会堵塞到结果运行结束。
    eg：
    class B implements Callable<String>{
    	...
    	public String call(){  ----  返回值类型要与参数类型相同
    		return "hahaha";
    	}
    }
    ....
    ExecutorService exec = Executors.newCachedThreadPool();
    ArrayList<Future<String>> list = new ArrayList<>();
    for(int i=0;i<10;i++){
    	list.add(exec.submit(new B()));  ----  在submit()方法中传入B对象，会直接调用B的call()方法，并且返回Future<>对象。
    }
    for(Future fs:list){
    	try{
    		System.out.println(fs.get());  ----  此处的get()会阻塞直到结果结算结束。
    	}catch(Execption e){
    		e.printStackTrace();
    	}finally{
    		exec.shutdown();  ----  不要忘了shutdown()
    	}
    }
  21.2.5 进程的休眠
    1.调用sleep()，将中止任务执行给定的时间.
    2.对sleep()的调用可以抛出InterruptedException异常并且可以在run()中被捕获。
    eg：
    class A1 extends A{
    	public void run(){
    		try{
    			super.doSomething();
    			TimeUnit.MILLISECONDS.sleep(100);
    		}catch(InterruptedException e){
    			e.printStackTrace();
    		}finally{}
    	}
    }
  21.2.6 优先级
    1.线程的优先级将该线程的重要性传递给调度器。
    2.优先级高的线程不代表着就总是会先运行，而是执行的频率比低优先级的线程高(不会导致死锁)
    3.使用getPriority()来获得优先级，用setPriority()来设置优先级。
    eg：
    class A implements Runnable{
    	private int priority;
    	...
    	public A(int num){priority=num;}
    	public void run(){
    		Thread.currentThread().setPriority(priority);  ----  在run()方法中对本线程设置优先级。Thread.currentThread()可以或者驱动该任务的Thread对象
    		...
    	}
    }
    ....
    ExecutorService exec = Executors.newCachedThreadPool();
    exec.execute(new A(Thread.MIN_PRIORITY));  ----  赋予低优先级
    exec.execute(new A(Thread.MAX_PRIORITY));  ----  赋予高优先级
    exec.shutdown();
    4.多种线程优先级之间的映射关系不太好，安全的做法是只使用三种优先级：MAX_PRIORITY,NORM_PRIORITY,MIN_PRIORITY
  21.2.7 让步
    1.暗示可以让别的线程使用CPU了，这个暗示就是yield()方法，但是仅仅是暗示，不一定就会被采纳。
    2.使用yield()实在建议具有相同优先级的其他线程可以运行了。
    3.可以对任务之间的分布进行一定的影响，但是任务的分布不能依赖于yield().
  21.2.8 后台线程
    1.后台线程：所有非后台线程结束之后，程序被视作结束，后台线程也会随之被中止。
    2.非后台线程：只要任何非后台进程存在程序就不会结束。
    3.将线程设置为后台线程要在线程开始之前调用.setDaemon(true)即可将线程设置为后台线程。
    eg：
    Thread daemon = new Thread(new A());
    daemon.setDaemon(true);  ----  只能在线程开始之前设置才会有效(不能像设置优先级那样在run()中间设置)
    daemon.start();
    4.ThreadFactory：Executor的构造器可以接受一个ThreadFactory，然后整个线程池中创建的线程将都由这个工厂产生，可以在此工厂中对创建的线程属性进行设置。
    eg：
    public class DaemonThreadFactory implements ThreadFactory{
    	public Thread newThread(Runnable r){
    		Thread t = new Thread(r);
    		t.setDaemon(true);  ----  这句话将工厂中的线程设置为了后台线程，所以从这个工厂产生的线程将都是后台线程
    		return t;
    	}
    }
    ....
    ExecutorService exec = Executors.newCachedThreadPool(new DaemonThreadFactory());
    exec.execute(new A());  ----  将使用一个从工厂中产生的后台线程执行A对象中的run()方法
    exec.shutdown();
    4.可以对Thread对象使用.isDaemon()判断该线程是否为后台线程，如果是，则该线程中所有创建的子线程也都将自动是后台线程。
    5.在程序结束的时候，JVM会突然的终止后台线程，甚至后台进程中的finally语句都不会得到执行。所以使用后台线程不总是一个好的办法，要尽可能使用非后台线程。
  21.2.9 代码的变体
    1.从Thread直接继承的子类，实现可以直接启动线程：
    class A extends Thread{
    	public A(){
    		super();
    		start();
    	}
    	public void run(){  ----  在Thread的子类中直接实现run()函数
    		//...
    	}
    }
    ....
    new A();  ----  run()直接开始执行
    2.通过代理Thread的方式，让Runnable对象可以自己管理自己：
    eg：
    class B implements Runnable{
    	private Thread t = new Thread(this);  ----  Thread以代理的方式出现在Runnbale类内
    	public void run(){}
    	public B(){
    		t.start();  ----  同样是在构造器中开始线程。
    	}
    }
    3.在构造器中开启线程的弊端：有可能会在构造器还没执行完的时候另一个任务就已经开始了，因为此时构造器的工作还没有结束(可能涉及到重要的初始化过程)，所以这会让多线程变得不稳定。这也是为什么Executor要使用静态方法类获得实例。(但是在相对简单的代码中，这样做是安全的)
    4.通过内部类启动线程：如果需要某些特殊的访问能力可以这样使用(比如新方法)，不然大多数情况下不必使用内部类
    eg：
    class A{
    	private Inner inner;  ----  创建内部类引用
    	private class Inner extends Thread{  ----  定义内部类
    		Inner(String name){  ----  在构造器中就启动线程
    			super(name);
    			start();
    		}
    		public void run(){}
    	}
    	public A(String name){inner = new Inner(name);}  ----  在外部类的构造器中创建内部类实例从而启动线程
    }
    5.匿名Thread类：
    eg：
    class B{
    	private Thread t;  ----  代理Thread对象
    	public B(String name){  ----  在构造器中创建Thread对象实例，并使用匿名类对run()进行定义
    		t = new Thread(name){
    			public void run(){}
    		};
    		t.start();  ----  在构造函数中启动线程
    	}
    }
    6.匿名Runnable类：
    eg：
    class C{
    	private Thread t;  ----  代理Thread对象
    	public C(String name){
    		t = new Thread(new Runnable(){  ----  在构造函数中创建Thread实例，并且将匿名Runnable对象直接作为参数赋给Thread
    			public void run(){}
    		},name);
    		t.start();  ----  启动线程
    	}
    }
    7.手动启动线程：可以在类创建之后的任何时间启动线程，只需要调用相应的方法就行
    class D{
    	private Thread t;
    	private String name;
    	public D(String name){this.name = name;}
    	public void runTask(){  ----  调用此方法将启动线程
    		if(t==null){
    			t = new Thread(name){
    				public void run(){}
    			};
    		}
    		t.start();
    	}
    }
  21.2.10 术语
  !21.2.11 加入一个线程
    1.可以对Thread对象调用.join()方法以实现加入功能。
    2.在a线程中执行b.join()，则a会挂起并且等待b线程执行结束之后，再执行a自己的任务。(就好像在a的中途加入一个b线程，所以b要先执行完a在接着执行)
    3.对join()的调用可以中断，做法是在调用线程上调用interrupt()。
    4.调用join()时，也可以带上一个超时参数。这样的话如果对应线程在固定时间内没有返回，join()也会自动返回并且继续调用线程的任务。
  21.2.14 捕获线程中的异常
    1.线程中抛出的异常是很难被捕获的(例如在main中启动多线程并且在线程中抛出异常，然后对main进行try-catch是并不能捕获到异常的)，需要使用Executor。
    2.在Executor中启动的线程，能捕获到异常。但是如果自己在Executor中制定了线程工厂，则要对线程工厂产生的线程上附着一个异常处理器。
    3.实现Thread.UncaughtExceptionHandler接口可以实现在线程里面捕获异常，这个接口只有一个方法void UncaughtException(Thread t,Throwable e)，这个方法会在线程因为未捕获异常而临近死亡的时候被调用。
    4.可以在线程启动之前，对线程.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());其中的MyUncaughtExceptionHandler()是手动创建的类(也可以在线程内调用.getUncaughtExceptionHandler()来获取自己的Handler)：
    eg：
    class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler{
    	public void UncaughtException(Thread t,Throwable e){
    		System.out.println("caught"+e);
    	}
    }
    5.可以将这个属性放在线程工厂中，以使Executor产生的线程都具有此特性：
    eg：
    class A implements ThreadFactory{
    	public void newThread(Runnable r){
    		Thread t = new Thread(r);
    		t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());  ----  将自己定义的Handler付给线程t
    		return t;
    	}
    }
    6.也可以用Thread的静态方法对所有Thread都添加默认的Handler：
    Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());  ----  使用这句话之后，Executor对象产生的线程将带有默认的Handler，如果线程有专有的Handler则使用线程专有的。
!!!21.3 共享受限资源
  21.3.1 不正确的访问资源
    1.一个任务不能依赖另一个任务，因为任务关闭的顺序无法得到保证。要让任务依赖于非任务对象，可以消除潜在的竞争条件。
    2.可以在线程中使用yield()以加速发现共享受限资源的问题。
  21.3.2 解决共享资源竞争
    1.防止冲突的办法就是当资源被一个任务使用时，对其加锁。第一个访问某项资源的任务必须锁定这个资源。解锁之后再由其他任务获取。
    2.加锁意味着同一时间只能有一个任务运行这段代码。因为锁语句产生了一种互相排斥的效果，这就叫做互斥量。
    3.synchronized关键字：
      (1)synchronized将检查锁是否可用，然后获取锁，执行代码。结束后释放锁。
      (2)除了对象之外，资源还可能是文件，输入/输出端口。加锁使要将他们封装为对象，然后在对象的方法中使用synchronized关键字。
      (3)使用方法：在返回值之前：
      eg：
      synchronized void f(){}
      (4)每个对象(实例)都会有一个单一的锁(监视器)。在这个对象上调用任何synchronized修饰的方法，次对象都会上锁。上锁的效果是该对象上其他synchronized方法(其他所有的synchronized方法都会上锁，不只是不同线程的同名方法)都会等待上一个synchronized方法执行结束了之后才会开始执行。
      (5)一个对象的所有synchronized方法都共享一个锁。
      (6)使用并发的时候将域设置为private非常重要，否则synchronized无法防止其他任务直接访问域(受保护的是方法，所以其他任务直接调用域无法受到synchronized的保护)
      (7)一个任务可以多次获得对象的锁：一个方法在同一个对象上调用了第二方法，然后又调用了其他方法。JVM会跟踪对象被加速的次数，并且计数，多一层锁就+1，锁为0时则视为彻底释放锁。
      (8)static synchronized：针对每个类(是类而不是单个的对象实例)的锁，static synchronized可以理解为为静态方法上的锁，而静态方法是整个类共有的。所以当调用同步静态方法时，不管有多少个同类对象调用都会遵循锁的机制来调用。
      (9)何时上锁：编写一个可能被另一个线程读取的变量要上锁，使用一个被其他线程修改过的变量要上锁。并且读写线程都必须使用相同的监视器锁同步(在同一个对象内写入/读取，将写入读取两个方法都设为synchronized这样读或者写同一时间只会存在一个)
      (10)如果一个类中有超过一个方法在处理临界数据，则必须同步所有相关方法。如果只同步一个方法，其他方法可能会忽略这个对象锁。
    4.显示调用Lock对象
      (1)Lock需要被显示的创建，锁定，释放。
      (2)创建Lock：Lock lock = new ReentrantLock();
      (3)锁定：lock.lock();
      (4)释放：lock.unlock();
      eg：
      class A{
      	private Lock lock = new ReentrantLock();  ----  可以在域中创建锁用以使用。
      	pubic int next(){
      		...
      		lock.lock();  ----  在需要加锁的代码前面调用.lock()
      		try{  ----  惯用法，使用try-catch。try之后的代码将被加锁
      			//...
      			int a = 0;
      			return a;  ----  如果需要return，则一定要放在try之中(因为在try中return,finally一样会在return之前执行)，这样会确保unlock()不会过早发生以暴露数据。
      		}catch(Exception e){
      			e.printStackTrace();
      		}finally{
      			lock.unlock();  ----  最终锁一定会被释放
      		}
      	}
      }
      (5)使用synchronized时，如果出现异常，则就只会抛出异常却没机会处理。但是使用try-catch+Lock可以使用finally语句将系统维护在正确的状态。
      (6)当synchronized不能获取锁，或者需要获取锁一段时间然后放弃锁的情况时候，才需要使用Lock。
      (7).tryLock():尝试获得锁，返回boolean。获取到锁返回true，反之返回false。
      eg：
      public void untimed(){
      	boolean captured = lock.tryLock();  ----  在try之外尝试获得锁，try之中可以针对获得锁，没获得锁做出不同的决策(就不用再没获得锁的同时一直阻塞，更灵活),将这句放在try外面是因为这句不会产生异常
      	try{
      		//...
      	}finally{
      		if(captured) lock.unlock();  ----  如果捕获到锁，则解锁(没捕获到也没有必要)
      	}
      }
      eg：
      public void timed(){
      	boolean captured = false;  ----  默认为没有捕获到锁
      	try{
      		captured = lock.tryLock(2,TimeUnit.SECONDS);  ----  尝试获取锁，该尝试会进行2秒，如果还获取不到锁则会视为失败。这句放在try之中是因为可能会抛出异常(比如中断，都阻塞了2秒制定可能中断)
      	}catch(InterruptedException e){
      		throw new RuntimeException(e);
      	}finally{
      		if(captured) lock.unlock();  ----  如果获取到锁就解锁。
      	}
      }
  21.3.3 原子性与易变性
    1.原子操作：就是不能被线程调度机制中断的操作。一旦操作开始，那么它一定可以在可能发生的上下文切换之前执行完毕。
    2.绝对不能只依靠原子性去处理并发问题！！！因为有时看起来应该是安全的原子性操作，也会变得不安全。
    3.原子性可以应用与除了long和double之外的所有基本类型上的简单操作(读写)。
    4.可视性问题：一个变量在某个线程做出修改，但是该值对其他任务可能是不可视的(可能只是暂时性的储存在本地处理器缓存中)，从而导致不同的任务拥有不同的视图。
    5.volatile关键字：用来修饰变量，确保了可视性。如果对volatile修饰的域，只要对这个域产生了写操作，那么所有的读操作都会看到这个修改(即使用了缓存也一样)，volatile会立即被写入到主存中(读写都发生在主存中)
      (1)如果一个域完全由synchronized方法或者语句块来防护，那么就不必将其设置为是volatile。
      (2)如果一个任务所做的任何写入操作对这个任务来说都是可视的(只需要在任务内部进行读写与外部任务没关系)，则不需要使用volatile关键字。
      (3)如果volatile的值依赖这个值之前的值(比如自加自减)，则volatile无效。(因为自加自减本身就不是原子性操作)
      (4)如果volatile的值依赖于其他域的限制(比如必须小于或者大于某个其他值)，volatile也无效。
      (5)只有在类中只有一个可变的域时，使用volatile才是安全的(只有一个可变的域表示这个可变的域并不受到类中的其他域的限制)
      (6)如果一个域可能会被多个和任务同时访问，或者这些任务中至少有一个是写入任务，就需要对域生命为volatile。
      (7)第一选择还是应该使用synchronized关键字。
      eg：
      class A{
      	private int a = 0;  ----  无需加volatile，因为a的全部读写操作都由synchronized修饰了。
      	public synchronized void increment(){  ----  加入synchronized用来同步a递增的过程，确保不会再两个递加中间被获取到a值。
      		a++;
      		a++;
      	}
      	public synchronized int getValue(){  ----  返回函数也要加上synchronized，防止在递增函数的中间获取到错误的值。
      		return a;
      	}
      }
  21.3.4 原子类
    1.引入了AtomicInteger,AtomicLong,AtomicReference等其他原子类并且提供原子性条件更新操作：boolean compareAndSet(expectedValue,updateValue);
    2.可以对整数原子类使用.addAndGet();实现安全的自加操作
    3.只有在特殊情况下才使用原子类，并且使用的时候要确保其真正安全。一般情况下还是使用锁比较好。
  21.3.5 临界区
    1.有时只希望防止多个线程同时访问方法内部的部分代码而不是防止整个方法。这种分离出来的代码段被称为临界区。临界区也使用synchronized进行限制：
    eg：
    synchronized(syncObject){  ----  在进入临界区之前制定要保护的对象，(该对象会上锁)
    	//...  ----  该代码段为收到保护
    }
    2.通过临界区而不是整个方法的同步控制，可以让多个任务访问对象的时间性能得到显著提高(会让对一个对象的安全访问此处得到提高)
    eg：
    public void increment(){
    	Pair temp;
    	synchronized(this){  ----  对本对象上锁
    		p.incrementX();
    		p.incrementY();
    	}
    }
    3.Lock其实也可以起到相同的作用：
    eg：
    public void increment(){
    	Pair temp;
    	lock.lock();
    	try{
    		p.incrementX();
    		p.incrementY();
    	}finally{
    		lock.unlock()；
    	}
    }
  21.3.6 在其他对象上同步
    1.在临界区的保护对象上使用其他对象，以保护该对象在临界区中的线程安全问题。
    2.当需要保护其他对象的时候，要确保临界区中的所有不安全的操作都是发生在该对象身上的。
  21.3.7 线程本地储存
    1.防止任务在共享资源上产生冲突的另一种办法就是根除对变量的共享。在不同的线程中对共享资源都创建不同的储存，各个任务互相独立，互不干涉。
    2.使用ThreadLocal<>来创建的变量，在多线程中运行的时候会在不同的线程中存储着不同的副本。ThreadLoacl<>变量只能用set()更新值，只能用get()获取值。
    eg：
    class A {
    	private static ThreadLocal<Integer> value = new ThreadLocal<>(){
    		protected synchronized Integer initialValue(){  ----  覆写方法，对变量赋初值
    			return 0;
    		}
    	}
    }
    ...
    value.set(value.get()+1);  ----  .get()获取变量的值，.set()更新变量的值
21.4 终结任务
  21.4.2 在阻塞时候终结
    1.线程状态：一个线程可以处于的四种状态：
      (1)新建(new)：当线程被创建时候，它只会短暂处于这种状态。此时它已经分配了必须的资源，并执行了初始化。之后调度器将把这个线程转变为可运行状态或者阻塞状态。
      (2)就绪(Runnable)：在这种状态下，只要调度器吧时间片分配给线程，线程就可以运行。但是在这种状态下的线程可以运行也可以不运行。
      (3)阻塞(Blocked)：线程能够运行，但是有某个条件阻止他的运行。当线程处于阻塞状态时候，调度器将忽略线程，不会分配线程任何CPU时间。直到线程进入了就绪状态，它才可能执行操作。
      (4)死亡(Dead)：处于死亡或者终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，任务已经结束吗或者不在可运行。线程死亡的通常方式是荣run()返回，或者通过中断。
    2.进入阻塞状态：一个任务进入阻塞状态的原因有以下四种：
      (1)通过调用sleep()让任务进入休眠状态。这种情况下任务在指定时间内不会运行。
      (2)通过wait()让线程挂起。直到线程得到了notify()或者notifyAll()消息时候，线程才会进入就绪状态。
      (3)任务在等待输入输出。
      (4)任务试图在某个对象上调用方法，但是该对象被锁。
    3.中断：有时需要终止处于阻塞状态的任务，但是阻塞状态下的任务不能通过判断值而进行停止。所以需要让他主动终止，这种方法就是中断。
      (1)java中的中断用到了异常，所以要在能抛出异常的部分自己编写catch语句以正确清楚所有事物。
      (2)Thread类包含interrupt()方法，这个方法将设置线程的中断状态。如果一个线程已经被堵塞或者试图执行一个阻塞操作，那么设置中断将让这个线程抛出InterruptedException。当抛出该异常的线程调用Thread(对象).interrupted()之后，此线程的中断状体会复位。
      (3)也可以通过Executor类对线程实施中断：
        (1)中断所有线程：如果在一个Executor上调用.shutdown()，将会给所有正在启动的线程中断。
        (2)中断特定线程：如果用submit()启动(而不是execute())，就可以持有该线程的上下文。因为submit()会返回一个Future<?>对象(持有这个对象将不能再其上调用.get())，可以在这个对象上调用cancel(true)，会引发此线程的中断：
        eg：
        Future<?> f = exec.submit(r);  ----  用submit()启动线程
        f.cancel(true);  ----  Executor会自动对此线程调用.interrupt()，达到中断的目的。
      (4)两类无法被中断的阻塞：
        (1)synchronized是不可中断的阻塞。
        (2)I/O操作是不可中断的：但是有时需要中断I/O操作，就是关闭任务在其上发生阻塞的底层资源。
      (5)被互斥锁阻塞：
        (1)在同步方法中再次调用同步方法可行，因为外部同步方法已经获取到锁了(安全)，内部再次调用将再次获得锁：
        eg：(省略了代理类A并继承自Runnable的线程类的定义)
        public A {
        	public synchronized void f1(int count){
        		if(count-->0){
        			f2(count);  ----  在f1()中调用f2()，两者都是同步方法，但是不会因互斥锁而锁住。
        		}
        	}
        	public synchronized void f2(int count){
        		if(count-->={
        			f1(count);  ----  在f2()中调用f1()，两者都是同步方法，f2()会再次获得锁。
             	}
        	}
        }
        (2)在Lock同步锁中实现中断：
        eg：
        lock.lock()
        lock.lockInterruptibly();  ----  让Lock可以被中断之后此Lock中就可以被中断了
  21.4.4 检查中断
    1.对一个线程调用.interrupt()之后，该线程只会在堵塞的时候捕获到中断异常，所以如果线程不进入可中断的状态中，就不会被中断。所以为了让线程在任何情况下都中断，应该使用以下惯用法：
    eg：
    public void run(){
    	try{  ----  进入函数立刻进入try-catch捕获中断异常
    		while(!Thread.interrupted()){  ----  如果已经被中断就不会向后执行而是直接捕获到异常退出。
    			A a1 = new A();  ----  在创建需要清理的对象后面立刻使用try-catch
    			try{  ----  立刻使用try-catch，如果此时发生中断，则finally会调用a1.cleanup()保证a1的正确清理。
    				A a2 = new A();  ----  如果需要创建另一个函数，也遵循同样的法则：创建需要清理的对象之后立刻使用try-catch，并在finally中写入清理方法。
    				try{

    				}finally{
    					a1.cleanup();  ----  确保中断时候会进行正确的清理
    				}
    			}finally{
    				a1.cleanup();  ----  确保中断时候会进行正确的清理
    			}

    		}
    	}catch(InterruptException e){
    		e.printStackTrace();  ----  或者其他的清理工作
    	}
    }
21.5 线程之间的协作
  1.有些步骤需要有一定先后顺序：比如盖房子先要盖地基，然后同时铺地板和按水管，等铺地板和按水管都完成之后再执行刷墙。其中即包含并发又包含非并发，这种情况就叫做线程之间的协作。
  21.5.1 wait()与notifyAll()
    1.wait()可以让你等待某个条件发生变化，而改变这个变化超出了当前方法的控制能力(通常改变将由另一个任务完成)。
      (1)调用wait()之前方法必须持有锁！！！(sleep()不持有锁的时候也可以执行)
      (2)调用wait()的时候，对象会释放当前锁。(sleep()不会释放锁)
      (3)当其他任务调用notifyAll()时候，wait()会恢复执行。
      (4)wait()可以接受一个时间参数，以控制其只等待一段时间。
    2.notifyAll()可以唤醒所有的wait()让其恢复执行，notifyAll()执行之前必须获得锁。
    3.wait()和notifyAll()是Object的方法，而不是Thread的。
    4.wait()惯用法：
    eg：
    while(a!=b){  ----  while中放置wait()等待的条件，当wait()被唤醒的时候
    	wait();  ----  等待，释放锁，当被notifyAll()唤醒时候，会对while()中的条件进行检查，如果符合条件则跳出循环，如果不符合条件则继续wait()
    }
    5.错失信号：
    eg：wait()的标准用法
    synchronized(sharedMonitor){  ----  用来获取锁
    	while(someCondition){  ----  防止notifyAll()在wait()之前调用，然后使wait()陷入死锁(这种情况下即使notify()提前调用根据改变之后的someCondition可以直接跳过wait())。
    		sharedMonitor.wait();
    	}
    }
  21.5.2 notify()与notifyAll()
    1.notifyAll()将唤醒只是在等待这个对象上的锁的方法。
  !!21.5.3 生产者与消费者
    1.情景：一个厨师和一个服务员，服务员必须等厨师准备好菜然后上菜。
    eg：
    public TaskDesk {  ----  可以作为线程池执行的平台类，其中会代理各个不同任务的类
    	private WaitPerson waitPerson;  ----  代理任务对象1
    	private Chef chef;  ----  代理任务对象2
    	public TaskDesk(){
    		waitPerson = new WaitPerson();  ----  实例化任务对象
    		chef = new Chef();
    		ExecutorService exec = newCachedThreadPool();  ----  创建线程池
    		exec.execute(waitPerson);  ----  分别开启两个实例化任务对象的线程
    		exec.execute(chef);
    	}
    	public static void main(String[] args){
    		new TaskDesk();
    	}
    }
    public Meal{  ----  消费者消费的东西，也是生产者会生产的东西
    	private static int orderNum=0;
    	private final int id;
    	public Meal(){
    		ordernum++;
    		id = ordernum;
    	}
    }
    class WaitPerson implements Runnable{  ----  WaitPerson类其中的run()会进行无限循环的任务
    	private TaskDesk taskDesk;
    	public WaitPerson(TaskDesk taskDesk){this.taskDesk=taskDesk;}
    	public void run(){
    		try{
    			while(!Thread.interrupted()){  ----  并发标准模板，此线程无线循环(因为是重复任务)
    				synchronized(this){
    					while(TaskDesk.meal==null) wait();  ----  等待的对象是自身，自身等待，所以锁住this
    				}
    				//point1  ----  在point1处，表示已经不再等待了表示，已经有meal在等待WaitPerson进行处理
    				synchronized(taskDesk.chef){
    					TaskDesk.meal=null;  ----  清空当前的meal(其实这一句就是真正的WaitPerson这个线程要做的任务)，要注意这句是在锁住了chef的情况下，因为当前线程此刻会对此变量进行修改，所以不允许chef对其进行修改。
    					taskDesk.chef.notifyAll();  ----  通知chef类的线程开始工作
    				}
    			}
    		}catch(InterruptedException e){  ----  并发标准模板，捕获中断
    			e.printStackTrace();
    		}
    	}
    }
    class Chef implements Runnable{
    	private TaskDesk taskDesk;
    	public Chef(TaskDesk taskDesk){TaskDesk taskDesk;}
    	public void run(){
    		try{
    			while(!Thread.interrupted()){
    				synchronized(this){
    					while(taskDesl.meal!=null) wait();
    				}
    				//point2
    				synchronized(taskDesk.waitPerson){
    					taskDesk.meal = new Meal();
    					taskDesk.waitPerson.notifyAll();
    				}
    			}
    		}catch(InterruptedException e){
    			e.printStackTrace();
    		}
    	}
    }
    2.使用显示的Lock和Condition对象：用await()代替wait()，用signal()/signalAll代替notify()/notifyAll()，用condition代替线程对象
    eg：
    public A{
    	private Lock lock = new ReentrantLock()；
    	private Condition condition = new lock.newCondition();
    	public void waxed() throws InterruptedException{  ----  将方法交给上级是为了在run中可以catch这个InterrupedException
    		lock.lock();
    		try{
    			//doSomething...
    			condition.signalAll();  ----  在condition上使用signalAll()
    		}finally{
    			lock.unlock();
    		}
    	}
    	public void waitForBuffering throws InterruptedException{
    		lock.lock();
    		try{
    			//doSomething...
    			while(waxOn==false) condition.await();
    		}finally{
    			lock.unlock();
    		}
    	}
    }
  21.5.4 生产者-消费者队列
    1.同步队列：内部提供同步机制，即同一时刻只允许一个任务插入或者移除元素
      (1)ArrayBlockingQueue：具有固定的尺寸，当满了的时候试图添加的任务将会被挂起。
      (2)LinkedBlockingQueue：无界队列，没有固定尺寸，可以向其中添加无线的任务。
      (3)BlockingQueue使用.put(T)存入对象，使用.take()取出对象。当队列已经满了的时候则.put()阻塞(如果为有界队列)，如果队列中没有对象的时候，则.take()阻塞。
      (4)BlockQueue内部是线程安全的(同一时间只会有一个任务在运行)，所以使用BlockQueue，不用对BlockQueue中的对象加锁或者其他同步方法。
    2.吐司BlockQueue：一台机器有三个任务：制作土司，给土司抹黄油，在抹过黄油的土司上涂果酱。
    eg：
    class Toast{  ----  生产消费物品
    	private final int id;
    	public enum Status{DRY,BUTTED,JAMMED};  ----  利用枚举类型储存状态。
    	public Toast(int id){this.id=id;}
    	public void butter(){status = Status.BUTTERED;}
    	public void jam(){static = Status.JAMEMD;}
    	public Status getStatus(){return status;}
    }
    class ToastQueue extends LinkedBlockingQueue<Toast> {}  ----  就等于用ToastQueue代替LinkedBlockingQueue<Toast>
    class Toaster implements Runnable{  ----  任务1线程，Toaster指用来进行烤土司任务的线程
    	private ToastQueue toastQueue;
    	private int count = 0;
    	public Toast(ToastQueue tq){toastQueue = tq;}
    	public void run(){
    		try{  ----  线程固定模板
    			while(!Thread.interrupted()){  ----  无线循环线程
    				//这里加一个延迟函数，用来模拟制作吐司的过程
    				Toast t = new Toast(count++);
    				toastQueue.put(t);  ----  将制作的土司放入队列中
    			}
    		}catch(InterruptedException e){
    			e.printStackTrace();
    		}
    	}
    }
    class Butterer implements Runnable{  ----  任务2线程，butterer指用来进行摸黄油的线程
    	private ToastQueue dryQueue,butteredQueue;  ----  一个干吐司队列，一个摸了黄油的队列(从干队列中取出黄油然后放到黄油队列中)
    	public Butterer(ToastQueue dry,ToastQueue buttered){
    		dryQueue = dry;
    		butteredQueue = buttered;
    	}
    	public void run(){
    		try{  ----  线程模板线程
    			while(!Thread.interrupted()){  ----  无线循环线程
    				Toast t = dryQueue.take();  ----  从干队列中取出吐司
    				t.butter();  ----  对此吐司抹黄油
    				butteredQueue.put(t);  ----  放到黄油队列中
    			}
    		}catch(InterruptedEception e){
    			e.printStackTrace();
    		}
    	}
    }
    class Jammer implements Runnable{  ----  任务3线程，jammer用来进行图果酱的线程
    	private butteredQueue,jammedQueue;  ----  一个摸了黄油的对了，一个吐了果酱的队列(从黄油队列中取出，然后涂过奖，然后放到果酱队列中)
    	Jammer(ToastQueue buttered,ToastQueue jammed){
    		butteredQueue = buttered;
    		jammedQueue = jammed;
    	}
    	public void run(){
    		try{  ----  固定线程模板
    			while(!Thread.interrupted()){  ----  无线循环线程
    				Toast t = butteredQueue.take();  ----  从黄油队列中取出
    				t.jam();  ----  涂果酱
    				jammedQueue.put(t);  ----  放到果酱队列中
    			}
    		}catch(InterruptedException e){
    			e.printStackTrace();
    		}
    	}
    }
    class Eater Implements Runnable{
    	private ToastQueue jammedQueue;
    	Eater(ToastQueue jammed){
    		jammedQueue = jammed;
    	}
    	public void run(){
    		try{
    			//在这里可以将最后队列中的土司取出然后执行一些吃的方法
    		}catch(InterruptedException e){
    			e.printStackTrace();
    		}
    	}
    }
    ....
    ToastQueue dryQueue = new ToastQueue();
    	butteredQueue = new ToastQueue();
    	jammedQueue = new ToastQueue();
    ExecutorService exec = Executors.newCachedThreadPool();
    exec.execute(new Toaster(dryQueue));
    exec.execute(new Butterer(dryQueue,butteredQueue));
    exec.execute(new Jammer(butteredQueue,jammedQueue));
    ....
  21.5.5 使用管道进行输入/输出
    1.同步的I/O方式
    2.P717
21.6 死锁
  1.当任务1在等待任务2的锁，然后任务2在等待任务3的锁，任务3在等待任务1的锁，所有任务都不会运行，这就是死锁。
  eg：哲学家吃饭问题P719
  2.线程间发生死锁的条件(必须所有条件都同时满足才会发生死锁)：
    (1)互斥条件。任务使用的资源中至少有一个是不能共享的。(存在一个不能被共享的资源，并且多个线程还有争抢此资源)
    (2)至少有一个任务必须持有一个共享资源，并且同时等待另一个共享资源。
    (3)共享的资源不会被其他任务抢占，一个任务获取之后，在没有完成其方法前不是放此资源，则其他任务永远不会获得到这个资源。
    (4)必须有循环等待：一个任务等待其他任务的资源，其他任务在等待另一个任务的资源，一直循环到有一个任务在等待第一个任务的资源。
  3.破坏死锁，只要破坏以上4个条件之一就不会发生死锁。
21.7 新类库中的构件
  21.7.1 CountDownLatch 
    1.CountDownLatch:向下计数锁存器，多个线程公用一个Latch，其中有些任务结束之后可以调用.countDown()，让CountDownLatch中的初始计数-1，直到为0时，调用了.await()的线程会被唤醒，从而进行最后的任务。可以理解为，选一个线程作为收尾(调用.await()等待其他任务结束)，其他任务都结束的时候(在结束的时候.countDown())收尾任务才会进行。.countDown()不会阻塞线程，.await()会阻塞线程
    2CountDownLatch无法重置计数器(只能使用一次)
    eg：
    class A implements Runnable{
    	private final CountDownLatch latch;
    	A(CountDownLatch ll){latch = ll;}
    	public void run(){
    		try{
    			doWork();  ----  完成这个线程的任务就会在latch上-1
    			latch.countDown();
    		}catch(InterruptedException e){
    			e.printStaceTrace();
    		}
    	}
    	public void doWork(){
    		//do something
    	}
    }
    class B implements Runnable{
    	private final CountDownLatch latch;
    	B(CountDownLatch ll){latch = ll;}
    	public void run(){
    		try{
    			latch.await();  ----  等待其他任务全部结束(实际上是等待latch的记数为0)
    		}catch(InterruptedException e){
    			e.printStackTrace();
    		}
    	}
    }
    ....
    ExecutorService exec = Executors.newCachedThreadPool();
    CountDownLatch latch = new CountDownLatch(5);  ----  5即为初始的计数值
    for(int i=0;i<5;i++){
    	exec.execute(new A(latch));
    }
    exec.execute(new B(latch));  ----  B会等到上面5个A都执行完毕之后才开始执行
  21.7.2 CyclicBarrier
    1.用于这样一种情况，你希望创建一组任务，他们并行的执行工作，然后再进行下一个步骤之前等待。直到所有的任务都完成。
    2.CyclicBarrier会自动重置计数器，就是说，在制定的任务完成之后会清空计数器，然后开始下一轮的计数，所以需要添加额外的退出线程的代码
    3.使用匿名类定义CyclicBarrier，此run()方法会在每一次计数为0时执行。(收尾操作)
    eg：
    class A implements Runnable{
    private static CyclicBarrier barrier;  ----  所有同类对象都是用一个barrier
    	public void run(){
    		try{
    			while(!Thread.interrupted()){
    				//dosomething...  ----  这里任务线程真正要做的事情，每次是无线循环线程(真正的操作是，多个这样的线程，每次等所有线程完成一次这样的操作，然后再一起开始下一次的操作)
    				barrier.await()；  ----  执行一次线程任务之后等待其他线程都完成一次任务，然后统一开始下一次任务
    			}
    		}catch(InterruptedException e){
    			e.printStackTrace();
    		}

    	}
    }
    public TaskDesk{
    	private ArrayList<A> list = new ArrayList<>();
    	private ExecutorService exec = Executors.newCachedThreadPool();
    	private CyclicBarrier barrier;
    	public HorseBarrier(int n){
    		barrier = new CyclicBarrier(n,new Runnable{
    			public void run(){
    				try{
    					//do something in the end of every single thread loop.  ----  收尾工作需要做的事情
    					//if(condition) return  ----  再收尾的时候进行一定的条件判断，提供推出条件，不然CyclicBarrier会在每次所有线程都结束的时候都重置计数器，不会停止。
    				}catch(InterruptedException e){
    					e.printStackTrace();
    				}
    			}
    		});
    		for(int i=0;i<n;i++){
    			A a = new A();
    			list.add(a);
    			exec.execute(a);  ----  在线程池中启动多个线程。
    		}
    	}
    }
    ....
    new TaskDesk();
  21.7.3 DelayQueue
    1.是一个无界的BlockQueue，用于放置实现了Delayed接口的对象，其中的对象只能在到期之后才能在队列中取走。
    2.这种队列是有序的：头对象是到期之后等待时间最久的对象，如果没有任务到期，则poll()会返回null(所以不能再这个队列中放入null)
    3.Delayed接口：long getDelay(Delayed d){}，输入为接口类，通过自己的定义返回任务还有多久到期。Delayed继承了Comparable接口，所以也要实现compareTo();
    eg：
    class DelayedTask implements Runnable, Delayed{
    	protected static List<DeleyedTask> list = new ArrayList<>();
    	private int delay;
    	public DelayedTask(int delay){
    		this.delay = delay;
    		list.add(this);
    	}
    	public int compareTo(Delayed arg){  ----  根据延迟的大小来比较DelayedTask的先后顺序，而且因为Delayed接口继承了Comparable接口，所以要实现compareTo()
    		DelayedTask dt = (DelayedTask)arg;  ----  向下转型将接口类型转型为具体的类型，然后才能使用具体的方法
    		//if(condition) return 1;  ----  通过自己定义的比较，选择返回1,-1,0
    		//else return -1
    		//return 0;
    	}
    	public long getDelay(TimeUnit unit){
    		//return...  ----  返回一个时间即可
    	}
    	public void run(){  ----  延时任务实际需要做的任务
    		try{
    			//do something
    		}catch(InterruptedException e){
    			e.printStackTrace();
    		}
    	}
    	public static class EndSentinel extends DelayedTask{  ----  使用静态内部类，对DelayedQueue的收尾工作进行定义
    		private ExecutorService exec;
    		public EndSentinel(int delay,ExecutorService e){
    			super(delay);  ----  使用父类的构造函数
    			exec = e;
    		}
    		public void run(){
    			//do something  ----  做一些收尾工作，会在外部进行手动调用
    			exec.shutdownNow();  ----  收尾工作结束之后，中断所有的线程
    		}
    	}
    }
    class TaskDesk implements Runnable{  ----  执行线程池的平台就是一个线程，将每一个从队列中取出的任务直接在本线程中执行(注意，所以就不会为每一个DelayedTask分配新的线程了)
    	private DelayQueue<DelayedTask> q;
    	public TaskDesk(DelayQueue<DelayTask> qq){
    		q=qq;
    	}
    	public void run(){
    		try{
    			while(!Thread.interrupted()){  ----  无线循环，不断地从队列中取出任务然后执行(因为都在本线程中执行，所以每一个DelayedTask会一个一个的执行)
    				q.take().run();
    			}
    		}catch(InterruptedException e){
    			e.printStackTrace();
    		}
    	}
    }
    ....
    ExecutorService exec = Executors.newCachedThreadPool();
    DelayQueue<DelayedTask> queue = new DelayQueue<>();
    for(int i=0;i<20;i++){
    	queue.put(new DelayedTask());
    }
    queue.add(new DelayTask.EndSentinel());  ----  手动在队列的尾部加入收尾对象，此对象是内部类
  21.7.4 PriorityBlockingQueue
    1.优先级队列，具有可阻塞的读取操作。取出的对象是按照优先级进行操作的。
    eg：
    class PrioritizedTask implements Runnable, Comparable<PrioritizedTask>{
    	private static List<PrioritizedTask> list = new ArrayList<>();  ----  在整个类中的静态List
    	private int proirity;
    	PrioritizedTask(int p){
    		priority = p;
    	}
    	public int compareTo(PrioritizedTask arg){  ----  实现接口用来比较优先级
    		return priority<arg.priority?1:(priority>arg.priority?-1:0);  ----  三元操作符的双重嵌套。
    	}
    	public void run(){
    		try{
    			//do something...  ----  不是无线循环线程
    		}catch(InterruptedException e){
    			e.printStackTrace();
    		}
    	}
    	public static class EndSentinel extends PrioritiedTask{  ----  内部类用来作为队列的最后一个任务，用来收尾(优先级为-1，最低)
    		...
    		EndSentinel(ExecutorService e){
    			super(-1);  ----  优先度为最低
    			exec = e;
    		}
    		....
    	}
    }
    class TaskDesk implements Runnable{
    	private PrioritizedBlockingQueue<Runnable> q;
    	TaskDesk(PrioritizedBlockingQueue<Runnable> e){
    		q = e;
    	}
    	public void run(){
    		try{
    			while(!Thread.interrupted()){
    				q.take().run();
    			}
    		}catch(InterruptedException e){
    			e.printStaceTrace();
    		}
    	}
    }
    ....
    ExecutorService exec = Executors.newCachedThreadPool();
    PrioritizedBlockingQueue<Runnable> queue = new PrioritizedBlockingQueue<>();
    exec.execute(new TaskDesk(queue));
  21.7.5 ScheduledExecutor
    1.使用ScheduledExecutor可以在内部定时进行任务的进行。
    2.两个API：
      (1).schedule(Runnable e,long delay,TimeUnit.MILLISECONDS){}  ----  e为需要执行的任务，delay为延迟多久进行，最后一个是单位，只运行一次
      (2).scheduleAtFixedRate(Runnable r,long delay,long period,TimeUnit.MILLISECONDS);  ----  e是需要的任务，delay为第一次执行的延迟，period是周期，最后是单位。
      (3)ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(10);  ----  初始化，其中10为最大任务数
    3.eg：P730
  21.7.6 Semaphore
    1.正常的锁在任何时刻都只允许一个任务访问一项资源，但是Semaphore允许n个任务同时访问这个资源。
    2.P733
  21.7.7 Exchanger
    1.两个任务同时持有一个Exchange，当两者都调用.exchange()的时候，会交换exchange()中的参数对象。如果只有一个任务调用了exchange，会阻塞直到另一个任务也使用exchange()
    2.P735
21.8 仿真
  1.银行出纳员仿真：P737
  2.饭店仿真：P741
  3.分发工作：P744
21.9 性能调优
  1.互斥锁的比较：
    (1)使用Lock通常会比使用synchronized要高效许多。
    (2)synchronized可读性强，可以从synchronized入手然后再需要优化性能的时候，再使用Lock+try-catch惯用法。
  2.免锁容器：
    (1)CopyOnWriteArrayList：免锁容器，在使用时候不需要上锁。底层实现：每一次写入都会在单独的线程内创建一个副本，在修改之后与原容器进行原子操作的交换。这样使得在修改容器数据的同时原数据依然可以正确被读取。
  3.乐观锁：
    (1)概念：试用于Atomic类，不使用互斥锁，当执行某项计算时，使用compareAndSet(oldValue,newValue)(返回boolean)的方法。将新值久值一起提交给这个方法，如果旧值与变量现在的值不一致，那么操作失败(意味着其他任务已经与此操作期间修改了这个对象)。但是要注意如果操作失败之后的处理方式。
21.10 活动对象
  1.概念：在你向一个活动对象发送消息的时候，这条消息会转变为一个任务。该任务会被插入到这个对象的队列中，等待在以后的某个时刻运行。
  2.eg：P763
  